/**
 * UNITNAVE Designer - Vista 2D CAD Profesional
 *
 * ✅ FIX CRÍTICO:
 * - Nunca renderiza rects con width/height <= 0
 * - detectAisles blindado contra width/height negativos
 * - Drag SVG con pointer events (robusto)
 * - ✅ FIX REAL: scale NUNCA negativo aunque el contenedor sea pequeño
 *
 * @version 2.3.1
 */

import React, { useMemo, useState, useCallback, useRef, useEffect } from 'react'
import { Box, Typography } from '@mui/material'

// ============================================================
// DEBUG
// ============================================================
const DEBUG_2D = typeof window !== 'undefined' && window.localStorage?.getItem('UN_DEBUG_2D') === '1'
const dlog = (...args: any[]) => DEBUG_2D && console.log(...args)
const dwarn = (...args: any[]) => DEBUG_2D && console.warn(...args)
const derr = (...args: any[]) => DEBUG_2D && console.error(...args)

const onceSet = new Set<string>()
const warnOnce = (key: string, ...args: any[]) => {
  if (!DEBUG_2D) return
  if (onceSet.has(key)) return
  onceSet.add(key)
  console.warn(...args)
}

// ============================================================
// COLORES POR TIPO DE ZONA (Estilo CAD profesional)
// ============================================================
const ZONE_COLORS: any = {
  shelf: { fill: '#3b82f6', stroke: '#1d4ed8', label: 'Estanterías' },
  dock: { fill: '#22c55e', stroke: '#15803d', label: 'Muelles' },
  dock_maneuver: { fill: '#86efac', stroke: '#22c55e', label: 'Zona Maniobra' },
  office: { fill: '#a855f7', stroke: '#7c3aed', label: 'Oficinas' },

  operational_zone: { fill: '#06b6d4', stroke: '#0891b2', label: 'Zona Operativa' },
  receiving: { fill: '#fbbf24', stroke: '#d97706', label: 'Recepción' },
  shipping: { fill: '#fb923c', stroke: '#ea580c', label: 'Expedición' },
  picking: { fill: '#f472b6', stroke: '#db2777', label: 'Picking' },

  service_room: { fill: '#f59e0b', stroke: '#b45309', label: 'Servicios' },
  technical_room: { fill: '#ef4444', stroke: '#b91c1c', label: 'Sala Técnica' },

  aisle: { fill: '#e2e8f0', stroke: '#94a3b8', label: 'Pasillo Operativo' },
  main_aisle: { fill: '#fef3c7', stroke: '#f59e0b', label: 'Pasillo Principal' },
  cross_aisle: { fill: '#dbeafe', stroke: '#3b82f6', label: 'Pasillo Transversal' },
  circulation: { fill: '#dcfce7', stroke: '#22c55e', label: 'Zona Circulación' },

  free_zone: { fill: '#f8fafc', stroke: '#cbd5e1', label: 'Zona Libre' },
  wall: { fill: '#64748b', stroke: '#475569', label: 'Muro' },

  selected: { fill: '#fef08a', stroke: '#eab308' },
  hover: { fill: '#bfdbfe', stroke: '#3b82f6' }
}

// ============================================================
// HELPERS
// ============================================================
const isFiniteNumber = (v: any) => Number.isFinite(v)
const toPosNumber = (v: any, fallback: number) => (isFiniteNumber(v) && v > 0 ? v : fallback)
const clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(max, v))
const snap = (v: number, step = 0.5) => Math.round(v / step) * step

// ✅ Qué zonas son “movibles” (elementos reales). NO pasillos, NO free_zone, NO dock_maneuver auto.
const MOVABLE_TYPES = new Set([
  'shelf',
  'dock',
  'office',
  'service_room',
  'technical_room',
  'operational_zone',
  'zone',
  'receiving',
  'shipping',
  'picking'
])

// ============================================================
// COMPONENTE ZONA INDIVIDUAL
// ============================================================
function Zone2D({
  zone,
  scale,
  offset,
  isSelected,
  isHovered,
  onMouseEnter,
  onMouseLeave,
  onClick,
  onPointerDownZone
}: any) {
  const { x, y, width, height, type, id, label, rotation = 0 } = zone

  // ✅ No render si zona inválida
  if (!(width > 0) || !(height > 0) || !isFiniteNumber(width) || !isFiniteNumber(height)) {
    warnOnce(`invalid-zone-${id}`, '[2DView] Zona inválida (no se dibuja):', { id, type, x, y, width, height })
    return null
  }

  const colors = useMemo(() => {
    if (isSelected) return ZONE_COLORS.selected
    if (isHovered) return ZONE_COLORS.hover
    return ZONE_COLORS[type] || ZONE_COLORS.free_zone
  }, [type, isSelected, isHovered])

  const svgX = offset.x + (x * scale)
  const svgY = offset.y + (y * scale)
  const svgWidth = width * scale
  const svgHeight = height * scale

  if (!(svgWidth > 0) || !(svgHeight > 0) || !isFiniteNumber(svgWidth) || !isFiniteNumber(svgHeight)) {
    warnOnce(`invalid-svg-${id}`, '[2DView] Rect SVG inválido (no se dibuja):', { id, type, svgWidth, svgHeight, scale })
    return null
  }

  const centerX = svgX + svgWidth / 2
  const centerY = svgY + svgHeight / 2

  const draggable =
    !!zone.element &&
    !zone.isAutoGenerated &&
    zone.type !== 'dock_maneuver' &&
    MOVABLE_TYPES.has(zone.type)

  return (
    <g
      className={`zone-target zone-${id}`}
      onMouseEnter={() => onMouseEnter(id)}
      onMouseLeave={onMouseLeave}
      onClick={() => onClick(zone)}
      onPointerDown={draggable ? (e: any) => onPointerDownZone?.(zone, e) : undefined}
      style={{ cursor: draggable ? 'grab' : 'pointer' }}
    >
      <rect
        x={svgX}
        y={svgY}
        width={svgWidth}
        height={svgHeight}
        fill={colors.fill}
        stroke={colors.stroke}
        strokeWidth={isSelected || isHovered ? 3 : 1.5}
        opacity={isSelected || isHovered ? 1 : 0.85}
        rx={2}
        ry={2}
        transform={rotation ? `rotate(${rotation}, ${centerX}, ${centerY})` : undefined}
      />

      {type === 'shelf' && svgWidth > 20 && svgHeight > 10 && (
        <g opacity={0.4} pointerEvents="none">
          {[0.25, 0.5, 0.75].map((pct, i) => (
            <line
              key={i}
              x1={svgX + 2}
              y1={svgY + svgHeight * pct}
              x2={svgX + svgWidth - 2}
              y2={svgY + svgHeight * pct}
              stroke={colors.stroke}
              strokeWidth={0.5}
              strokeDasharray="2,2"
            />
          ))}
        </g>
      )}

      {type === 'dock' && (
        <g pointerEvents="none">
          <rect
            x={svgX + svgWidth * 0.1}
            y={svgY}
            width={svgWidth * 0.8}
            height={3}
            fill="#15803d"
          />
          <path
            d={`M ${centerX} ${svgY + 8} L ${centerX - 5} ${svgY + 15} L ${centerX + 5} ${svgY + 15} Z`}
            fill={colors.stroke}
            opacity={0.6}
          />
        </g>
      )}

      {svgWidth > 30 && svgHeight > 20 && (
        <text
          x={centerX}
          y={centerY}
          textAnchor="middle"
          dominantBaseline="middle"
          fontSize={Math.min(11, svgWidth / 5)}
          fontFamily="'JetBrains Mono', 'Fira Code', monospace"
          fontWeight={600}
          fill={isSelected || isHovered ? '#1f2937' : colors.stroke}
          pointerEvents="none"
        >
          {label || id}
        </text>
      )}

      {(isHovered || isSelected) && (
        <g pointerEvents="none">
          <text
            x={centerX}
            y={svgY - 6}
            textAnchor="middle"
            fontSize={9}
            fontFamily="'JetBrains Mono', monospace"
            fill="#374151"
          >
            {Number(width).toFixed(1)}m
          </text>
          <text
            x={svgX + svgWidth + 6}
            y={centerY}
            textAnchor="start"
            dominantBaseline="middle"
            fontSize={9}
            fontFamily="'JetBrains Mono', monospace"
            fill="#374151"
          >
            {Number(height).toFixed(1)}m
          </text>
        </g>
      )}
    </g>
  )
}

// ============================================================
// COMPONENTE COTAS/DIMENSIONES
// ============================================================
function DimensionLines({ dimensions, scale, offset }: any) {
  const length = toPosNumber(dimensions?.length, 80)
  const width = toPosNumber(dimensions?.width, 40)

  const svgLength = length * scale
  const svgWidth = width * scale

  return (
    <g className="dimension-lines" pointerEvents="none">
      <g>
        <line
          x1={offset.x}
          y1={offset.y + svgWidth + 25}
          x2={offset.x + svgLength}
          y2={offset.y + svgWidth + 25}
          stroke="#1e40af"
          strokeWidth={1}
          markerStart="url(#arrow-start)"
          markerEnd="url(#arrow-end)"
        />
        <text
          x={offset.x + svgLength / 2}
          y={offset.y + svgWidth + 40}
          textAnchor="middle"
          fontSize={12}
          fontFamily="'JetBrains Mono', monospace"
          fontWeight={600}
          fill="#1e40af"
        >
          {length.toFixed(1)} m
        </text>
      </g>

      <g>
        <line
          x1={offset.x + svgLength + 25}
          y1={offset.y}
          x2={offset.x + svgLength + 25}
          y2={offset.y + svgWidth}
          stroke="#1e40af"
          strokeWidth={1}
          markerStart="url(#arrow-start)"
          markerEnd="url(#arrow-end)"
        />
        <text
          x={offset.x + svgLength + 40}
          y={offset.y + svgWidth / 2}
          textAnchor="middle"
          dominantBaseline="middle"
          fontSize={12}
          fontFamily="'JetBrains Mono', monospace"
          fontWeight={600}
          fill="#1e40af"
          transform={`rotate(90, ${offset.x + svgLength + 40}, ${offset.y + svgWidth / 2})`}
        >
          {width.toFixed(1)} m
        </text>
      </g>
    </g>
  )
}

// ============================================================
// COMPONENTE GRID
// ============================================================
function Grid2D({ dimensions, scale, offset, gridSize = 5 }: any) {
  const length = toPosNumber(dimensions?.length, 80)
  const width = toPosNumber(dimensions?.width, 40)

  const lines = useMemo(() => {
    const result: any[] = []
    for (let x = 0; x <= length; x += gridSize) {
      result.push({
        key: `v-${x}`,
        x1: offset.x + x * scale,
        y1: offset.y,
        x2: offset.x + x * scale,
        y2: offset.y + width * scale,
        major: x % (gridSize * 2) === 0
      })
    }
    for (let y = 0; y <= width; y += gridSize) {
      result.push({
        key: `h-${y}`,
        x1: offset.x,
        y1: offset.y + y * scale,
        x2: offset.x + length * scale,
        y2: offset.y + y * scale,
        major: y % (gridSize * 2) === 0
      })
    }
    return result
  }, [length, width, scale, offset, gridSize])

  return (
    <g className="grid-2d" pointerEvents="none">
      {lines.map((line) => (
        <line
          key={line.key}
          x1={line.x1}
          y1={line.y1}
          x2={line.x2}
          y2={line.y2}
          stroke={line.major ? '#d1d5db' : '#e5e7eb'}
          strokeWidth={line.major ? 0.8 : 0.4}
        />
      ))}
    </g>
  )
}

// ============================================================
// FUNCIÓN PARA PROCESAR ELEMENTOS A ZONAS
// ============================================================
function processElementsToZones(elements: any[], dimensions: any) {
  const zones: any = []
  const shelves: any[] = []

  const L = toPosNumber(dimensions?.length, 80)
  const W = toPosNumber(dimensions?.width, 40)

  ;(elements || []).forEach((el, index) => {
    const type = el.type
    const x = isFiniteNumber(el.position?.x) ? el.position.x : 0
    const y = isFiniteNumber(el.position?.y) ? el.position.y : (isFiniteNumber(el.position?.z) ? el.position.z : 0)
    const rotation = isFiniteNumber(el.rotation) ? el.rotation : 0

    let width: number, height: number

    switch (type) {
      case 'shelf':
        width = toPosNumber(el.dimensions?.length, 2.7)
        height = toPosNumber(el.dimensions?.depth, 1.1)
        break
      case 'dock':
        width = toPosNumber(el.dimensions?.width, 3.5)
        height = toPosNumber(el.dimensions?.depth, 0.5)
        break
      case 'office':
        width = toPosNumber(el.dimensions?.length ?? el.dimensions?.largo, 12)
        height = toPosNumber(el.dimensions?.width ?? el.dimensions?.ancho, 8)
        break
      case 'operational_zone':
      case 'zone':
      case 'receiving':
      case 'shipping':
      case 'picking':
        width = toPosNumber(el.dimensions?.length ?? el.dimensions?.largo, 10)
        height = toPosNumber(el.dimensions?.width ?? el.dimensions?.ancho, 10)
        break
      case 'service_room':
      case 'technical_room':
        width = toPosNumber(el.dimensions?.length ?? el.dimensions?.largo, 5)
        height = toPosNumber(el.dimensions?.width ?? el.dimensions?.ancho, 4)
        break
      default:
        width = toPosNumber(el.dimensions?.length, 3)
        height = toPosNumber(el.dimensions?.depth ?? el.dimensions?.width, 3)
    }

    if (!(width > 0) || !(height > 0)) {
      warnOnce(`bad-el-size-${el.id}`, '[2DView] Elemento con size inválido (saltado):', { id: el.id, type, width, height })
      return
    }

    if (DEBUG_2D) {
      const outX = x < 0 || (x + width) > L
      const outY = y < 0 || (y + height) > W
      if (outX || outY) {
        dwarn('[2DView] Elemento fuera de límites:', { id: el.id, type, x, y, width, height, L, W })
      }
    }

    const zoneData: any = {
      id: el.id,
      originalId: el.id,
      type,
      x,
      y,
      width,
      height,
      rotation,
      label: el.properties?.label || `${type.charAt(0).toUpperCase()}${type.slice(1)} ${index + 1}`,
      area: width * height,
      element: el
    }

    zones.push(zoneData)
    if (type === 'shelf') shelves.push(zoneData)

    if (type === 'dock') {
      const maneuverZone = toPosNumber(el.dimensions?.maneuverZone, 4)
      zones.push({
        id: `${el.id}-maneuver`,
        originalId: el.id,
        type: 'dock_maneuver',
        x: x,
        y: y + height,
        width: width,
        height: maneuverZone,
        rotation: 0,
        label: 'Zona Maniobra',
        area: width * maneuverZone,
        element: el
      })
    }
  })

  const aisles = detectAisles(shelves, dimensions, elements || [])
  aisles.forEach((aisle: any) => zones.push(aisle))

  const totalArea = L * W
  const occupiedArea = zones.reduce((sum: number, z: any) => sum + (z.area || 0), 0)
  const freeArea = totalArea - occupiedArea

  zones.freeArea = freeArea
  zones.totalArea = totalArea
  zones.occupiedArea = occupiedArea

  return zones
}

// ============================================================
// detectAisles + helpers (BLINDADO)
// ============================================================
function elementToRect(el: any) {
  const x0 = isFiniteNumber(el.position?.x) ? el.position.x : 0
  const y0 = isFiniteNumber(el.position?.y) ? el.position.y : (isFiniteNumber(el.position?.z) ? el.position.z : 0)

  let w: number, h: number

  switch (el.type) {
    case 'shelf':
      w = toPosNumber(el.dimensions?.length, 2.7)
      h = toPosNumber(el.dimensions?.depth, 1.1)
      break
    case 'dock':
      w = toPosNumber(el.dimensions?.width, 3.5)
      h = toPosNumber(el.dimensions?.depth, 0.5) + 4
      break
    case 'office':
      w = toPosNumber(el.dimensions?.length ?? el.dimensions?.largo, 12)
      h = toPosNumber(el.dimensions?.width ?? el.dimensions?.ancho, 8)
      break
    case 'operational_zone':
    case 'zone':
    case 'receiving':
    case 'shipping':
    case 'picking':
      w = toPosNumber(el.dimensions?.length ?? el.dimensions?.largo, 10)
      h = toPosNumber(el.dimensions?.width ?? el.dimensions?.ancho, 10)
      break
    case 'service_room':
    case 'technical_room':
      w = toPosNumber(el.dimensions?.length ?? el.dimensions?.largo, 5)
      h = toPosNumber(el.dimensions?.width ?? el.dimensions?.ancho, 4)
      break
    default:
      w = toPosNumber(el.dimensions?.length, 3)
      h = toPosNumber(el.dimensions?.depth ?? el.dimensions?.width, 3)
  }

  return { x: x0, y: y0, w, h, x2: x0 + w, y2: y0 + h, type: el.type }
}

function clampRectToBounds(r: any, L: number, W: number) {
  const x1 = clamp(r.x, 0, L)
  const y1 = clamp(r.y, 0, W)
  const x2 = clamp(r.x2, 0, L)
  const y2 = clamp(r.y2, 0, W)

  const left = Math.min(x1, x2)
  const right = Math.max(x1, x2)
  const top = Math.min(y1, y2)
  const bottom = Math.max(y1, y2)

  const w = right - left
  const h = bottom - top

  if (!(w > 0) || !(h > 0)) return null

  return { x: left, y: top, w, h, x2: right, y2: bottom, type: r.type }
}

function detectAisles(shelves: any[], dimensions: any, allElements: any[]) {
  const zones: any[] = []
  const PRECISION = 0.5

  const L = toPosNumber(dimensions?.length, 80)
  const W = toPosNumber(dimensions?.width, 40)

  const obstaclesRaw = allElements.map(elementToRect)

  allElements.forEach((el) => {
    if (el.type === 'dock') {
      const x = isFiniteNumber(el.position?.x) ? el.position.x : 0
      const y = isFiniteNumber(el.position?.y) ? el.position.y : 0
      const w = toPosNumber(el.dimensions?.width, 3.5)
      const depth = toPosNumber(el.dimensions?.depth, 0.5)
      const maneuverDepth = 4

      obstaclesRaw.push({
        x, y: y + depth,
        w, h: maneuverDepth,
        x2: x + w, y2: y + depth + maneuverDepth,
        type: 'dock_maneuver'
      })
    }
  })

  const obstacles = obstaclesRaw
    .map((r: any) => clampRectToBounds(r, L, W))
    .filter(Boolean)

  const yPoints = new Set<number>([0, W])
  obstacles.forEach((obs: any) => {
    yPoints.add(obs.y)
    yPoints.add(obs.y2)
  })
  const sortedY = [...yPoints].sort((a, b) => a - b)

  const freeRects: any[] = []

  for (let i = 0; i < sortedY.length - 1; i++) {
    const y1 = sortedY[i]
    const y2 = sortedY[i + 1]
    const stripHeight = y2 - y1
    if (!(stripHeight > PRECISION)) continue

    const stripObstacles = obstacles
      .filter((obs: any) => obs.y < y2 && obs.y2 > y1)
      .sort((a: any, b: any) => a.x - b.x)

    let currentX = 0

    for (const obs of stripObstacles) {
      const gapW = obs.x - currentX
      if (gapW > PRECISION) {
        freeRects.push({ x: currentX, y: y1, width: gapW, height: stripHeight })
      }
      currentX = Math.max(currentX, obs.x2)
      if (currentX >= L) break
    }

    const tailW = L - currentX
    if (tailW > PRECISION) {
      freeRects.push({ x: currentX, y: y1, width: tailW, height: stripHeight })
    }
  }

  const mergedRects = mergeVerticalRects(freeRects, PRECISION)

  mergedRects.forEach((rect: any, index: number) => {
    const { x, y, width, height } = rect
    if (!(width > 0) || !(height > 0)) return

    const area = width * height
    if (area < 1) return

    let type: string, label: string

    if (width <= 4 && height > 6) {
      type = width >= 3 ? 'cross_aisle' : 'aisle'
      label = width >= 3 ? 'Pasillo Transversal' : 'Pasillo Operativo'
    } else if (height <= 4 && width > 6) {
      type = height >= 3 ? 'main_aisle' : 'aisle'
      label = height >= 3 ? 'Pasillo Principal' : 'Pasillo Operativo'
    } else if (width <= 5 || height <= 5) {
      type = 'aisle'
      label = 'Pasillo'
    } else if (area > 100) {
      type = 'circulation'
      if (y < 10) label = 'Zona Circulación Norte'
      else if (y > W - 15) label = 'Zona Circulación Sur'
      else if (x < 10) label = 'Zona Circulación Oeste'
      else if (x > L - 15) label = 'Zona Circulación Este'
      else label = 'Zona Circulación'
    } else {
      type = 'free_zone'
      label = 'Zona Libre'
    }

    zones.push({
      id: `free-${index}`,
      originalId: `free-${index}`,
      type,
      x,
      y,
      width,
      height,
      rotation: 0,
      label,
      area,
      isAutoGenerated: true
    })
  })

  return zones
}

function mergeVerticalRects(rects: any[], tolerance: number) {
  if (!rects.length) return []
  const groups = new Map<string, any[]>()

  rects.forEach((rect) => {
    if (!(rect.width > 0) || !(rect.height > 0)) return
    const keyX = Math.round(rect.x / tolerance) * tolerance
    const keyW = Math.round(rect.width / tolerance) * tolerance
    const key = `${keyX}-${keyW}`
    if (!groups.has(key)) groups.set(key, [])
    groups.get(key)!.push(rect)
  })

  const merged: any[] = []

  groups.forEach((group) => {
    group.sort((a, b) => a.y - b.y)
    let current = { ...group[0] }

    for (let i = 1; i < group.length; i++) {
      const next = group[i]
      if (Math.abs(next.y - (current.y + current.height)) <= tolerance) {
        current.height = (next.y + next.height) - current.y
      } else {
        merged.push(current)
        current = { ...next }
      }
    }
    merged.push(current)
  })

  return mergeHorizontalRects(merged, tolerance)
}

function mergeHorizontalRects(rects: any[], tolerance: number) {
  if (!rects.length) return []
  const groups = new Map<string, any[]>()

  rects.forEach((rect) => {
    if (!(rect.width > 0) || !(rect.height > 0)) return
    const keyY = Math.round(rect.y / tolerance) * tolerance
    const keyH = Math.round(rect.height / tolerance) * tolerance
    const key = `${keyY}-${keyH}`
    if (!groups.has(key)) groups.set(key, [])
    groups.get(key)!.push(rect)
  })

  const merged: any[] = []
  groups.forEach((group) => {
    group.sort((a, b) => a.x - b.x)
    let current = { ...group[0] }

    for (let i = 1; i < group.length; i++) {
      const next = group[i]
      if (Math.abs(next.x - (current.x + current.width)) <= tolerance) {
        current.width = (next.x + next.width) - current.x
      } else {
        merged.push(current)
        current = { ...next }
      }
    }
    merged.push(current)
  })

  return merged
}

// ============================================================
// COMPONENTE PRINCIPAL
// ============================================================
export default function Warehouse2DView({
  dimensions = { length: 80, width: 40, height: 10 },
  elements = [],
  onZoneSelect,
  onZoneHover,
  selectedZoneId,
  hoveredZoneId,
  externalZones = null,
  showGrid = true,
  showDimensions = true,
  zoom = 100,
  onElementMoveEnd,
  onDraggingChange
}: any) {
  const containerRef = useRef<any>(null)
  const svgRef = useRef<SVGSVGElement | null>(null)

  const [viewBox, setViewBox] = useState({ width: 800, height: 500 })
  const [internalHover, setInternalHover] = useState<string | null>(null)
  const [internalSelected, setInternalSelected] = useState<string | null>(null)

  const effectiveHover = hoveredZoneId ?? internalHover
  const effectiveSelected = selectedZoneId ?? internalSelected

  const localZones = useMemo(() => {
    return processElementsToZones(elements, dimensions)
  }, [elements, dimensions])

  const zones = useMemo(() => {
    if (externalZones && externalZones.length > 0) {
      const elementZones = localZones.filter((z: any) => !z.isAutoGenerated)
      const backendAutoZones = externalZones.filter((z: any) => z.isAutoGenerated)

      const result: any = [...elementZones, ...backendAutoZones]
      result.freeArea = externalZones.freeArea || localZones.freeArea
      result.totalArea = externalZones.totalArea || localZones.totalArea
      result.occupiedArea = externalZones.occupiedArea || localZones.occupiedArea

      return result
    }
    return localZones
  }, [externalZones, localZones])

  // ✅ scale = unidades SVG por metro (FIX: nunca negativo)
  const { scale, offset } = useMemo(() => {
    const padding = 80
    const L = toPosNumber(dimensions.length, 80)
    const W = toPosNumber(dimensions.width, 40)

    // ✅ evita available negativos cuando el contenedor es pequeño
    const availableWidth = Math.max(50, viewBox.width - padding * 2)
    const availableHeight = Math.max(50, viewBox.height - padding * 2)

    const scaleX = availableWidth / L
    const scaleY = availableHeight / W

    // ✅ scale SIEMPRE positiva y finita
    const baseScale = Math.max(0.01, Math.min(scaleX, scaleY))

    const offsetX = (viewBox.width - L * baseScale) / 2
    const offsetY = (viewBox.height - W * baseScale) / 2

    return { scale: baseScale, offset: { x: offsetX, y: offsetY } }
  }, [viewBox, dimensions.length, dimensions.width])

  useEffect(() => {
    const updateSize = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect()
        // ✅ evita viewBox minúsculo durante renders/transiciones
        const w = Math.max(200, rect.width || 0)
        const h = Math.max(200, rect.height || 0)
        setViewBox({ width: w || 800, height: h || 500 })
        dlog('[2DView][resize] container:', rect.width, rect.height, '-> viewBox', w, h)
      }
    }
    updateSize()
    window.addEventListener('resize', updateSize)
    return () => window.removeEventListener('resize', updateSize)
  }, [])

  const handleZoneMouseEnter = useCallback((id: string) => {
    setInternalHover(id)
    onZoneHover?.(id)
  }, [onZoneHover])

  const handleZoneMouseLeave = useCallback(() => {
    setInternalHover(null)
    onZoneHover?.(null)
  }, [onZoneHover])

  const handleZoneClick = useCallback((zone: any) => {
    setInternalSelected(zone.id)
    onZoneSelect?.(zone)
  }, [onZoneSelect])

  // ============================================================
  // ✅ DRAG REAL SVG
  // ============================================================
  const dragRef = useRef<any>(null)

  const clientToMeters = useCallback((clientX: number, clientY: number) => {
    const svg = svgRef.current
    if (!svg) return { mx: 0, my: 0 }

    const rect = svg.getBoundingClientRect()
    const vx = (clientX - rect.left) * (viewBox.width / rect.width)
    const vy = (clientY - rect.top) * (viewBox.height / rect.height)
    const mx = (vx - offset.x) / scale
    const my = (vy - offset.y) / scale
    return { mx, my }
  }, [viewBox.width, viewBox.height, offset.x, offset.y, scale])

  const onPointerDownZone = useCallback((zone: any, e: any) => {
    if (e.button !== 0) return

    e.preventDefault()
    e.stopPropagation()

    const draggable =
      !!zone.element &&
      !zone.isAutoGenerated &&
      zone.type !== 'dock_maneuver' &&
      MOVABLE_TYPES.has(zone.type)

    if (!draggable) {
      dlog('[2DView][drag] pointerDown en zona NO movible:', { id: zone.id, type: zone.type })
      return
    }

    onDraggingChange?.(true)

    setInternalSelected(zone.id)
    onZoneSelect?.(zone)

    const g = e.currentTarget
    const { mx, my } = clientToMeters(e.clientX, e.clientY)

    dragRef.current = {
      targetEl: g,
      elementId: zone.originalId || zone.id,
      startMouseX: mx,
      startMouseY: my,
      startX: zone.x,
      startY: zone.y,
      w: zone.width,
      h: zone.height,
      lastX: zone.x,
      lastY: zone.y,
      moves: 0
    }

    try { g.style.cursor = 'grabbing' } catch {}

    dlog('[2DView][drag] START', {
      id: dragRef.current.elementId,
      startX: zone.x, startY: zone.y,
      w: zone.width, h: zone.height,
      mouse: { mx, my }
    })

    const onMove = (ev: any) => {
      if (!dragRef.current) return
      ev.preventDefault()

      const d = dragRef.current
      const p = clientToMeters(ev.clientX, ev.clientY)

      let newX = d.startX + (p.mx - d.startMouseX)
      let newY = d.startY + (p.my - d.startMouseY)

      newX = snap(newX, 0.5)
      newY = snap(newY, 0.5)

      newX = clamp(newX, 0, toPosNumber(dimensions.length, 80) - d.w)
      newY = clamp(newY, 0, toPosNumber(dimensions.width, 40) - d.h)

      d.lastX = newX
      d.lastY = newY

      const dxSvg = (newX - d.startX) * scale
      const dySvg = (newY - d.startY) * scale
      d.targetEl.setAttribute('transform', `translate(${dxSvg}, ${dySvg})`)

      d.moves += 1
      if (DEBUG_2D && d.moves % 20 === 0) {
        dlog('[2DView][drag] MOVE', { id: d.elementId, newX, newY, moves: d.moves })
      }
    }

    const onUp = (ev: any) => {
      if (!dragRef.current) return
      ev.preventDefault()

      const d = dragRef.current
      dragRef.current = null

      try { d.targetEl.removeAttribute('transform') } catch {}
      try { d.targetEl.style.cursor = 'grab' } catch {}

      dlog('[2DView][drag] END', { id: d.elementId, x: d.lastX, y: d.lastY, moves: d.moves })

      onElementMoveEnd?.(d.elementId, d.lastX, d.lastY)
      onDraggingChange?.(false)

      window.removeEventListener('pointermove', onMove)
      window.removeEventListener('pointerup', onUp)
      window.removeEventListener('pointercancel', onUp)
    }

    window.addEventListener('pointermove', onMove, { passive: false })
    window.addEventListener('pointerup', onUp, { passive: false })
    window.addEventListener('pointercancel', onUp, { passive: false })
  }, [
    clientToMeters,
    dimensions.length,
    dimensions.width,
    scale,
    onElementMoveEnd,
    onZoneSelect,
    onDraggingChange
  ])

  useEffect(() => {
    if (!DEBUG_2D) return
    const invalid = zones.filter((z: any) => !(z.width > 0) || !(z.height > 0))
    if (invalid.length) {
      derr('[2DView] ZONAS INVÁLIDAS (no deberían existir). sample:', invalid.slice(0, 10))
    } else {
      dlog('[2DView] zones OK:', zones.length)
    }
  }, [zones])

  // ✅ Guard final: si algo raro pasa con scale, no renderizamos SVG roto.
  if (!Number.isFinite(scale) || !(scale > 0)) {
    return (
      <Box sx={{ p: 2 }}>
        <Typography variant="body2">Vista 2D no disponible (scale inválido).</Typography>
      </Box>
    )
  }

  const Lm = toPosNumber(dimensions.length, 80)
  const Wm = toPosNumber(dimensions.width, 40)

  return (
    <Box
      ref={containerRef}
      sx={{
        width: '100%',
        height: '100%',
        bgcolor: '#fafafa',
        position: 'relative',
        overflow: 'hidden'
      }}
    >
      <svg
        ref={svgRef}
        width="100%"
        height="100%"
        viewBox={`0 0 ${viewBox.width} ${viewBox.height}`}
        style={{
          fontFamily: "'JetBrains Mono', 'Fira Code', 'SF Mono', monospace",
          userSelect: 'none',
          touchAction: 'none'
        }}
      >
        <defs>
          <marker id="arrow-start" markerWidth="8" markerHeight="8" refX="0" refY="4" orient="auto">
            <path d="M8,0 L0,4 L8,8" fill="none" stroke="#1e40af" strokeWidth="1" />
          </marker>
          <marker id="arrow-end" markerWidth="8" markerHeight="8" refX="8" refY="4" orient="auto">
            <path d="M0,0 L8,4 L0,8" fill="none" stroke="#1e40af" strokeWidth="1" />
          </marker>

          <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
            <feDropShadow dx="2" dy="2" stdDeviation="3" floodOpacity="0.15" />
          </filter>
        </defs>

        <rect x={0} y={0} width={viewBox.width} height={viewBox.height} fill="#fafafa" />

        {showGrid && (
          <Grid2D dimensions={dimensions} scale={scale} offset={offset} gridSize={5} />
        )}

        {/* ✅ perímetro (siempre positivo porque scale>0 y Lm/Wm>0) */}
        <rect
          x={offset.x}
          y={offset.y}
          width={Lm * scale}
          height={Wm * scale}
          fill="#ffffff"
          stroke="#374151"
          strokeWidth={3}
          filter="url(#shadow)"
        />

        <g className="zones">
          {zones.filter((z: any) => ['aisle', 'main_aisle', 'cross_aisle', 'circulation'].includes(z.type)).map((zone: any) => (
            <Zone2D
              key={zone.id}
              zone={zone}
              scale={scale}
              offset={offset}
              isSelected={effectiveSelected === zone.id}
              isHovered={effectiveHover === zone.id}
              onMouseEnter={handleZoneMouseEnter}
              onMouseLeave={handleZoneMouseLeave}
              onClick={handleZoneClick}
              onPointerDownZone={onPointerDownZone}
            />
          ))}

          {zones.filter((z: any) => z.type === 'dock_maneuver').map((zone: any) => (
            <Zone2D
              key={zone.id}
              zone={zone}
              scale={scale}
              offset={offset}
              isSelected={effectiveSelected === zone.id || effectiveSelected === zone.originalId}
              isHovered={effectiveHover === zone.id || effectiveHover === zone.originalId}
              onMouseEnter={handleZoneMouseEnter}
              onMouseLeave={handleZoneMouseLeave}
              onClick={handleZoneClick}
              onPointerDownZone={onPointerDownZone}
            />
          ))}

          {zones.filter((z: any) => ['operational_zone', 'zone', 'receiving', 'shipping', 'picking'].includes(z.type)).map((zone: any) => (
            <Zone2D
              key={zone.id}
              zone={zone}
              scale={scale}
              offset={offset}
              isSelected={effectiveSelected === zone.id}
              isHovered={effectiveHover === zone.id}
              onMouseEnter={handleZoneMouseEnter}
              onMouseLeave={handleZoneMouseLeave}
              onClick={handleZoneClick}
              onPointerDownZone={onPointerDownZone}
            />
          ))}

          {zones.filter((z: any) => ['office', 'service_room', 'technical_room'].includes(z.type)).map((zone: any) => (
            <Zone2D
              key={zone.id}
              zone={zone}
              scale={scale}
              offset={offset}
              isSelected={effectiveSelected === zone.id}
              isHovered={effectiveHover === zone.id}
              onMouseEnter={handleZoneMouseEnter}
              onMouseLeave={handleZoneMouseLeave}
              onClick={handleZoneClick}
              onPointerDownZone={onPointerDownZone}
            />
          ))}

          {zones.filter((z: any) => z.type === 'shelf').map((zone: any) => (
            <Zone2D
              key={zone.id}
              zone={zone}
              scale={scale}
              offset={offset}
              isSelected={effectiveSelected === zone.id}
              isHovered={effectiveHover === zone.id}
              onMouseEnter={handleZoneMouseEnter}
              onMouseLeave={handleZoneMouseLeave}
              onClick={handleZoneClick}
              onPointerDownZone={onPointerDownZone}
            />
          ))}

          {zones.filter((z: any) => z.type === 'dock').map((zone: any) => (
            <Zone2D
              key={zone.id}
              zone={zone}
              scale={scale}
              offset={offset}
              isSelected={effectiveSelected === zone.id}
              isHovered={effectiveHover === zone.id}
              onMouseEnter={handleZoneMouseEnter}
              onMouseLeave={handleZoneMouseLeave}
              onClick={handleZoneClick}
              onPointerDownZone={onPointerDownZone}
            />
          ))}
        </g>

        {showDimensions && (
          <DimensionLines dimensions={dimensions} scale={scale} offset={offset} />
        )}

        <g transform={`translate(${viewBox.width - 50}, 50)`}>
          <circle cx={0} cy={0} r={20} fill="#f1f5f9" stroke="#64748b" strokeWidth={1} />
          <path d="M0,-15 L5,10 L0,5 L-5,10 Z" fill="#374151" />
          <text x={0} y={-22} textAnchor="middle" fontSize={10} fontWeight={600} fill="#374151">N</text>
        </g>

        <g transform={`translate(${offset.x}, ${offset.y + Wm * scale + 60})`}>
          <rect x={0} y={0} width={10 * scale} height={6} fill="#374151" />
          <rect x={10 * scale} y={0} width={10 * scale} height={6} fill="#94a3b8" />
          <text x={0} y={18} fontSize={9} fill="#64748b">0</text>
          <text x={10 * scale} y={18} fontSize={9} fill="#64748b" textAnchor="middle">10m</text>
          <text x={20 * scale} y={18} fontSize={9} fill="#64748b" textAnchor="middle">20m</text>
        </g>

        <text
          x={viewBox.width / 2}
          y={25}
          textAnchor="middle"
          fontSize={14}
          fontWeight={700}
          fill="#1f2937"
        >
          PLANO DE PLANTA - {Lm}m × {Wm}m ({(Lm * Wm).toLocaleString()}m²)
        </text>
      </svg>

      <Box
        sx={{
          position: 'absolute',
          bottom: 16,
          left: 16,
          bgcolor: 'rgba(255,255,255,0.95)',
          borderRadius: 1,
          px: 2,
          py: 1,
          boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
          fontFamily: 'monospace',
          fontSize: 11
        }}
      >
        <Typography variant="caption" sx={{ fontWeight: 600, color: '#374151' }}>
          Zonas: {zones.length} | Ocupado: {zones.occupiedArea?.toFixed(0) || 0}m² | Libre: {zones.freeArea?.toFixed(0) || 0}m²
        </Typography>
      </Box>
    </Box>
  )
}

export { processElementsToZones, ZONE_COLORS }
