/**
 * UNITNAVE Designer - Vista 2D CAD Profesional
 *
 * ✅ Ahora con:
 * - Cotas como antes
 * - Drag & drop REAL en SVG (sin Moveable)
 * - onElementMoveEnd(id,x,y) para re-optimizar en backend
 *
 * @version 2.2
 */

import React, { useMemo, useState, useCallback, useRef, useEffect } from 'react'
import { Box, Typography } from '@mui/material'

// ===================== DEBUG =====================
const DBG = true
const log = (...a) => DBG && console.log('[2DView]', ...a)
const group = (t, fn) => {
  if (!DBG) return
  console.groupCollapsed(t)
  try { fn?.() } finally { console.groupEnd() }
}
// ================================================

const ZONE_COLORS = {
  shelf: { fill: '#3b82f6', stroke: '#1d4ed8', label: 'Estanterías' },
  dock: { fill: '#22c55e', stroke: '#15803d', label: 'Muelles' },
  dock_maneuver: { fill: '#86efac', stroke: '#22c55e', label: 'Zona Maniobra' },
  office: { fill: '#a855f7', stroke: '#7c3aed', label: 'Oficinas' },
  operational_zone: { fill: '#06b6d4', stroke: '#0891b2', label: 'Zona Operativa' },
  receiving: { fill: '#fbbf24', stroke: '#d97706', label: 'Recepción' },
  shipping: { fill: '#fb923c', stroke: '#ea580c', label: 'Expedición' },
  picking: { fill: '#f472b6', stroke: '#db2777', label: 'Picking' },
  service_room: { fill: '#f59e0b', stroke: '#b45309', label: 'Servicios' },
  technical_room: { fill: '#ef4444', stroke: '#b91c1c', label: 'Sala Técnica' },
  aisle: { fill: '#e2e8f0', stroke: '#94a3b8', label: 'Pasillo Operativo' },
  main_aisle: { fill: '#fef3c7', stroke: '#f59e0b', label: 'Pasillo Principal' },
  cross_aisle: { fill: '#dbeafe', stroke: '#3b82f6', label: 'Pasillo Transversal' },
  circulation: { fill: '#dcfce7', stroke: '#22c55e', label: 'Zona Circulación' },
  free_zone: { fill: '#f8fafc', stroke: '#cbd5e1', label: 'Zona Libre' },
  wall: { fill: '#64748b', stroke: '#475569', label: 'Muro' },
  selected: { fill: '#fef08a', stroke: '#eab308' },
  hover: { fill: '#bfdbfe', stroke: '#3b82f6' }
}

const clamp = (v, min, max) => Math.max(min, Math.min(max, v))
const snap = (v, step = 0.5) => Math.round(v / step) * step

const MOVABLE_TYPES = new Set([
  'shelf',
  'dock',
  'office',
  'service_room',
  'technical_room',
  'operational_zone',
  'zone',
  'receiving',
  'shipping',
  'picking'
])

function Zone2D({
  zone,
  scale,
  offset,
  isSelected,
  isHovered,
  onMouseEnter,
  onMouseLeave,
  onClick,
  onPointerDownZone
}) {
  const { x, y, width, height, type, id, label, rotation = 0 } = zone

  const colors = useMemo(() => {
    if (isSelected) return ZONE_COLORS.selected
    if (isHovered) return ZONE_COLORS.hover
    return ZONE_COLORS[type] || ZONE_COLORS.free_zone
  }, [type, isSelected, isHovered])

  const svgX = offset.x + (x * scale)
  const svgY = offset.y + (y * scale)
  const svgWidth = width * scale
  const svgHeight = height * scale

  const centerX = svgX + svgWidth / 2
  const centerY = svgY + svgHeight / 2

  const draggable =
    !!zone.element &&
    !zone.isAutoGenerated &&
    zone.type !== 'dock_maneuver' &&
    MOVABLE_TYPES.has(zone.type)

  return (
    <g
      className={`zone-target zone-${id}`}
      onMouseEnter={() => onMouseEnter(id)}
      onMouseLeave={onMouseLeave}
      onClick={() => onClick(zone)}
      style={{ cursor: draggable ? 'grab' : 'pointer' }}
    >
      {/* ✅ HANDLER AQUÍ (rect) = MUCHO MÁS FIABLE */}
      <rect
        x={svgX}
        y={svgY}
        width={svgWidth}
        height={svgHeight}
        fill={colors.fill}
        stroke={colors.stroke}
        strokeWidth={isSelected || isHovered ? 3 : 1.5}
        opacity={isSelected || isHovered ? 1 : 0.85}
        rx={2}
        ry={2}
        transform={rotation ? `rotate(${rotation}, ${centerX}, ${centerY})` : undefined}
        onPointerDown={draggable ? (e) => onPointerDownZone?.(zone, e) : undefined}
        onMouseDown={draggable ? (e) => onPointerDownZone?.(zone, e) : undefined} // fallback
        style={{ cursor: draggable ? 'grab' : 'pointer' }}
      />

      {type === 'shelf' && svgWidth > 20 && svgHeight > 10 && (
        <g opacity={0.4} pointerEvents="none">
          {[0.25, 0.5, 0.75].map((pct, i) => (
            <line
              key={i}
              x1={svgX + 2}
              y1={svgY + svgHeight * pct}
              x2={svgX + svgWidth - 2}
              y2={svgY + svgHeight * pct}
              stroke={colors.stroke}
              strokeWidth={0.5}
              strokeDasharray="2,2"
            />
          ))}
        </g>
      )}

      {type === 'dock' && (
        <g pointerEvents="none">
          <rect x={svgX + svgWidth * 0.1} y={svgY} width={svgWidth * 0.8} height={3} fill="#15803d" />
          <path
            d={`M ${centerX} ${svgY + 8} L ${centerX - 5} ${svgY + 15} L ${centerX + 5} ${svgY + 15} Z`}
            fill={colors.stroke}
            opacity={0.6}
          />
        </g>
      )}

      {svgWidth > 30 && svgHeight > 20 && (
        <text
          x={centerX}
          y={centerY}
          textAnchor="middle"
          dominantBaseline="middle"
          fontSize={Math.min(11, svgWidth / 5)}
          fontFamily="'JetBrains Mono', 'Fira Code', monospace"
          fontWeight={600}
          fill={isSelected || isHovered ? '#1f2937' : colors.stroke}
          pointerEvents="none"
        >
          {label || id}
        </text>
      )}
    </g>
  )
}

function DimensionLines({ dimensions, scale, offset }) {
  const { length, width } = dimensions
  const svgLength = length * scale
  const svgWidth = width * scale

  return (
    <g className="dimension-lines" pointerEvents="none">
      <g>
        <line
          x1={offset.x}
          y1={offset.y + svgWidth + 25}
          x2={offset.x + svgLength}
          y2={offset.y + svgWidth + 25}
          stroke="#1e40af"
          strokeWidth={1}
          markerStart="url(#arrow-start)"
          markerEnd="url(#arrow-end)"
        />
        <text
          x={offset.x + svgLength / 2}
          y={offset.y + svgWidth + 40}
          textAnchor="middle"
          fontSize={12}
          fontFamily="'JetBrains Mono', monospace"
          fontWeight={600}
          fill="#1e40af"
        >
          {length.toFixed(1)} m
        </text>
      </g>

      <g>
        <line
          x1={offset.x + svgLength + 25}
          y1={offset.y}
          x2={offset.x + svgLength + 25}
          y2={offset.y + svgWidth}
          stroke="#1e40af"
          strokeWidth={1}
          markerStart="url(#arrow-start)"
          markerEnd="url(#arrow-end)"
        />
        <text
          x={offset.x + svgLength + 40}
          y={offset.y + svgWidth / 2}
          textAnchor="middle"
          dominantBaseline="middle"
          fontSize={12}
          fontFamily="'JetBrains Mono', monospace"
          fontWeight={600}
          fill="#1e40af"
          transform={`rotate(90, ${offset.x + svgLength + 40}, ${offset.y + svgWidth / 2})`}
        >
          {width.toFixed(1)} m
        </text>
      </g>
    </g>
  )
}

function Grid2D({ dimensions, scale, offset, gridSize = 5 }) {
  const { length, width } = dimensions

  const lines = useMemo(() => {
    const result = []
    for (let x = 0; x <= length; x += gridSize) {
      result.push({
        key: `v-${x}`,
        x1: offset.x + x * scale,
        y1: offset.y,
        x2: offset.x + x * scale,
        y2: offset.y + width * scale,
        major: x % (gridSize * 2) === 0
      })
    }
    for (let y = 0; y <= width; y += gridSize) {
      result.push({
        key: `h-${y}`,
        x1: offset.x,
        y1: offset.y + y * scale,
        x2: offset.x + length * scale,
        y2: offset.y + y * scale,
        major: y % (gridSize * 2) === 0
      })
    }
    return result
  }, [dimensions, scale, offset, gridSize])

  return (
    <g className="grid-2d" pointerEvents="none">
      {lines.map(line => (
        <line
          key={line.key}
          x1={line.x1}
          y1={line.y1}
          x2={line.x2}
          y2={line.y2}
          stroke={line.major ? '#d1d5db' : '#e5e7eb'}
          strokeWidth={line.major ? 0.8 : 0.4}
        />
      ))}
    </g>
  )
}

/* =================== TU processElementsToZones + helpers (sin tocar) =================== */
function processElementsToZones(elements, dimensions) {
  const zones = []
  const shelves = []

  elements.forEach((el, index) => {
    const type = el.type
    const x = el.position?.x ?? 0
    const y = el.position?.y ?? el.position?.z ?? 0
    const rotation = el.rotation || 0

    let width, height
    switch (type) {
      case 'shelf':
        width = el.dimensions?.length ?? 2.7
        height = el.dimensions?.depth ?? 1.1
        break
      case 'dock':
        width = el.dimensions?.width ?? 3.5
        height = el.dimensions?.depth ?? 0.5
        break
      case 'office':
        width = el.dimensions?.length ?? el.dimensions?.largo ?? 12
        height = el.dimensions?.width ?? el.dimensions?.ancho ?? 8
        break
      case 'operational_zone':
      case 'zone':
        width = el.dimensions?.length ?? el.dimensions?.largo ?? 10
        height = el.dimensions?.width ?? el.dimensions?.ancho ?? 10
        break
      case 'service_room':
      case 'technical_room':
        width = el.dimensions?.length ?? el.dimensions?.largo ?? 5
        height = el.dimensions?.width ?? el.dimensions?.ancho ?? 4
        break
      default:
        width = el.dimensions?.length ?? 3
        height = el.dimensions?.depth ?? el.dimensions?.width ?? 3
    }

    const zoneData = {
      id: el.id,
      originalId: el.id,
      type,
      x,
      y,
      width,
      height,
      rotation,
      label: el.properties?.label || `${type.charAt(0).toUpperCase()}${type.slice(1)} ${index + 1}`,
      area: width * height,
      element: el
    }

    zones.push(zoneData)
    if (type === 'shelf') shelves.push(zoneData)

    if (type === 'dock') {
      const maneuverZone = el.dimensions?.maneuverZone ?? 4
      zones.push({
        id: `${el.id}-maneuver`,
        originalId: el.id,
        type: 'dock_maneuver',
        x: x,
        y: y + (el.dimensions?.depth ?? 0.5),
        width: width,
        height: maneuverZone,
        rotation: 0,
        label: 'Zona Maniobra',
        area: width * maneuverZone,
        element: el
      })
    }
  })

  const aisles = detectAisles(shelves, dimensions, elements)
  aisles.forEach(aisle => zones.push(aisle))

  const totalArea = dimensions.length * dimensions.width
  const occupiedArea = zones.reduce((sum, z) => sum + z.area, 0)
  const freeArea = totalArea - occupiedArea

  zones.freeArea = freeArea
  zones.totalArea = totalArea
  zones.occupiedArea = occupiedArea

  return zones
}

function elementToRect(el) {
  const x = el.position?.x ?? 0
  const y = el.position?.y ?? el.position?.z ?? 0
  let w, h

  switch (el.type) {
    case 'shelf':
      w = el.dimensions?.length ?? 2.7
      h = el.dimensions?.depth ?? 1.1
      break
    case 'dock':
      w = el.dimensions?.width ?? 3.5
      h = (el.dimensions?.depth ?? 0.5) + 4
      break
    case 'office':
      w = el.dimensions?.length ?? el.dimensions?.largo ?? 12
      h = el.dimensions?.width ?? el.dimensions?.ancho ?? 8
      break
    case 'operational_zone':
    case 'zone':
      w = el.dimensions?.length ?? el.dimensions?.largo ?? 10
      h = el.dimensions?.width ?? el.dimensions?.ancho ?? 10
      break
    case 'service_room':
    case 'technical_room':
      w = el.dimensions?.length ?? el.dimensions?.largo ?? 5
      h = el.dimensions?.width ?? el.dimensions?.ancho ?? 4
      break
    default:
      w = el.dimensions?.length ?? 3
      h = el.dimensions?.depth ?? el.dimensions?.width ?? 3
  }

  return { x, y, w, h, x2: x + w, y2: y + h, type: el.type }
}

function detectAisles(shelves, dimensions, allElements) {
  const zones = []
  const PRECISION = 0.5
  const obstacles = allElements.map(elementToRect)

  allElements.forEach(el => {
    if (el.type === 'dock') {
      const x = el.position?.x ?? 0
      const y = el.position?.y ?? 0
      const w = el.dimensions?.width ?? 3.5
      const maneuverDepth = 4
      obstacles.push({
        x, y: y + (el.dimensions?.depth ?? 0.5),
        w, h: maneuverDepth,
        x2: x + w, y2: y + (el.dimensions?.depth ?? 0.5) + maneuverDepth,
        type: 'dock_maneuver'
      })
    }
  })

  const yPoints = new Set([0, dimensions.width])
  obstacles.forEach(obs => {
    yPoints.add(Math.max(0, obs.y))
    yPoints.add(Math.min(dimensions.width, obs.y2))
  })
  const sortedY = [...yPoints].sort((a, b) => a - b)

  const freeRects = []
  for (let i = 0; i < sortedY.length - 1; i++) {
    const y1 = sortedY[i]
    const y2 = sortedY[i + 1]
    const stripHeight = y2 - y1
    if (stripHeight < PRECISION) continue

    const stripObstacles = obstacles.filter(obs => obs.y < y2 && obs.y2 > y1).sort((a, b) => a.x - b.x)
    let currentX = 0

    stripObstacles.forEach(obs => {
      if (obs.x > currentX) {
        freeRects.push({ x: currentX, y: y1, width: obs.x - currentX, height: stripHeight })
      }
      currentX = Math.max(currentX, obs.x2)
    })

    if (currentX < dimensions.length) {
      freeRects.push({ x: currentX, y: y1, width: dimensions.length - currentX, height: stripHeight })
    }
  }

  const mergedRects = mergeVerticalRects(freeRects, PRECISION)

  mergedRects.forEach((rect, index) => {
    const { x, y, width, height } = rect
    const area = width * height
    if (area < 1) return

    let type, label
    if (width <= 4 && height > 6) {
      type = width >= 3 ? 'cross_aisle' : 'aisle'
      label = width >= 3 ? 'Pasillo Transversal' : 'Pasillo Operativo'
    } else if (height <= 4 && width > 6) {
      type = height >= 3 ? 'main_aisle' : 'aisle'
      label = height >= 3 ? 'Pasillo Principal' : 'Pasillo Operativo'
    } else if (width <= 5 || height <= 5) {
      type = 'aisle'
      label = 'Pasillo'
    } else if (area > 100) {
      type = 'circulation'
      if (y < 10) label = 'Zona Circulación Norte'
      else if (y > dimensions.width - 15) label = 'Zona Circulación Sur'
      else if (x < 10) label = 'Zona Circulación Oeste'
      else if (x > dimensions.length - 15) label = 'Zona Circulación Este'
      else label = 'Zona Circulación'
    } else {
      type = 'free_zone'
      label = 'Zona Libre'
    }

    zones.push({
      id: `free-${index}`,
      originalId: `free-${index}`,
      type,
      x,
      y,
      width,
      height,
      rotation: 0,
      label,
      area,
      isAutoGenerated: true
    })
  })

  return zones
}

function mergeVerticalRects(rects, tolerance) {
  if (rects.length === 0) return []
  const groups = new Map()

  rects.forEach(rect => {
    const keyX = Math.round(rect.x / tolerance) * tolerance
    const keyW = Math.round(rect.width / tolerance) * tolerance
    const key = `${keyX}-${keyW}`
    if (!groups.has(key)) groups.set(key, [])
    groups.get(key).push(rect)
  })

  const merged = []
  groups.forEach(group => {
    group.sort((a, b) => a.y - b.y)
    let current = { ...group[0] }

    for (let i = 1; i < group.length; i++) {
      const next = group[i]
      if (Math.abs(next.y - (current.y + current.height)) <= tolerance) {
        current.height = (next.y + next.height) - current.y
      } else {
        merged.push(current)
        current = { ...next }
      }
    }
    merged.push(current)
  })

  return mergeHorizontalRects(merged, tolerance)
}

function mergeHorizontalRects(rects, tolerance) {
  if (rects.length === 0) return []
  const groups = new Map()

  rects.forEach(rect => {
    const keyY = Math.round(rect.y / tolerance) * tolerance
    const keyH = Math.round(rect.height / tolerance) * tolerance
    const key = `${keyY}-${keyH}`
    if (!groups.has(key)) groups.set(key, [])
    groups.get(key).push(rect)
  })

  const merged = []
  groups.forEach(group => {
    group.sort((a, b) => a.x - b.x)
    let current = { ...group[0] }

    for (let i = 1; i < group.length; i++) {
      const next = group[i]
      if (Math.abs(next.x - (current.x + current.width)) <= tolerance) {
        current.width = (next.x + next.width) - current.x
      } else {
        merged.push(current)
        current = { ...next }
      }
    }
    merged.push(current)
  })

  return merged
}
/* ====================================================================================== */

export default function Warehouse2DView({
  dimensions = { length: 80, width: 40, height: 10 },
  elements = [],
  onZoneSelect,
  onZoneHover,
  selectedZoneId,
  hoveredZoneId,
  externalZones = null,
  showGrid = true,
  showDimensions = true,
  zoom = 100,
  onElementMoveEnd,
  onDraggingChange // ✅ NUEVO (lo usa el editor)
}) {
  useEffect(() => {
    console.log('[LOAD][Warehouse2DView]', import.meta?.url || '(no import.meta.url)')
  }, [])

  const containerRef = useRef(null)
  const svgRef = useRef(null)

  const [viewBox, setViewBox] = useState({ width: 800, height: 500 })
  const [internalHover, setInternalHover] = useState(null)
  const [internalSelected, setInternalSelected] = useState(null)

  const effectiveHover = hoveredZoneId ?? internalHover
  const effectiveSelected = selectedZoneId ?? internalSelected

  const localZones = useMemo(() => processElementsToZones(elements, dimensions), [elements, dimensions])

  const zones = useMemo(() => {
    if (externalZones && externalZones.length > 0) {
      const elementZones = localZones.filter(z => !z.isAutoGenerated)
      const backendAutoZones = externalZones.filter(z => z.isAutoGenerated)
      const result = [...elementZones, ...backendAutoZones]
      result.freeArea = externalZones.freeArea || localZones.freeArea
      result.totalArea = externalZones.totalArea || localZones.totalArea
      result.occupiedArea = externalZones.occupiedArea || localZones.occupiedArea
      return result
    }
    return localZones
  }, [externalZones, localZones])

  const { scale, offset } = useMemo(() => {
    const padding = 80
    const availableWidth = viewBox.width - padding * 2
    const availableHeight = viewBox.height - padding * 2
    const scaleX = availableWidth / dimensions.length
    const scaleY = availableHeight / dimensions.width
    const baseScale = Math.min(scaleX, scaleY)
    const offsetX = (viewBox.width - dimensions.length * baseScale) / 2
    const offsetY = (viewBox.height - dimensions.width * baseScale) / 2
    return { scale: baseScale, offset: { x: offsetX, y: offsetY } }
  }, [viewBox, dimensions.length, dimensions.width])

  useEffect(() => {
    const updateSize = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect()
        setViewBox({
          width: rect.width || 800,
          height: rect.height || 500
        })
        log('[resize] container:', rect.width, rect.height)
      }
    }
    updateSize()
    window.addEventListener('resize', updateSize)
    return () => window.removeEventListener('resize', updateSize)
  }, [])

  // Watchdog overlay: qué elemento está encima
  useEffect(() => {
    const svg = svgRef.current
    if (!svg) return
    const handler = (e) => {
      if (!DBG) return
      const el = document.elementFromPoint(e.clientX, e.clientY)
      if (!el) return
      // solo “a veces” para no spamear
      if (Math.random() < 0.03) {
        log('[elementFromPoint]', el.tagName, el.getAttribute?.('class'))
      }
    }
    svg.addEventListener('pointermove', handler, { passive: true })
    return () => svg.removeEventListener('pointermove', handler)
  }, [])

  const handleZoneMouseEnter = useCallback((id) => {
    setInternalHover(id)
    onZoneHover?.(id)
  }, [onZoneHover])

  const handleZoneMouseLeave = useCallback(() => {
    setInternalHover(null)
    onZoneHover?.(null)
  }, [onZoneHover])

  const handleZoneClick = useCallback((zone) => {
    setInternalSelected(zone.id)
    onZoneSelect?.(zone)
  }, [onZoneSelect])

  // ================= DRAG =================
  const dragRef = useRef(null)

  const clientToMeters = useCallback((clientX, clientY) => {
    const svg = svgRef.current
    if (!svg) return { mx: 0, my: 0 }

    const rect = svg.getBoundingClientRect()
    const vx = (clientX - rect.left) * (viewBox.width / rect.width)
    const vy = (clientY - rect.top) * (viewBox.height / rect.height)
    const mx = (vx - offset.x) / scale
    const my = (vy - offset.y) / scale
    return { mx, my }
  }, [viewBox.width, viewBox.height, offset.x, offset.y, scale])

  const endDragCleanup = useCallback((onMove, onUp) => {
    window.removeEventListener('pointermove', onMove)
    window.removeEventListener('pointerup', onUp)
    window.removeEventListener('pointercancel', onUp)
    window.removeEventListener('mousemove', onMove)
    window.removeEventListener('mouseup', onUp)
  }, [])

  const onPointerDownZone = useCallback((zone, e) => {
    // botón principal (en mouse). Si es pointer/touch, lo dejamos pasar.
    if (typeof e.button === 'number' && e.button !== 0) return

    e.preventDefault()
    e.stopPropagation()

    group('[DRAG][DOWN]', () => {
      console.log('zone:', { id: zone.id, originalId: zone.originalId, type: zone.type, auto: zone.isAutoGenerated, hasElement: !!zone.element })
      console.log('scale/offset:', { scale, offset, viewBox })
      console.log('onElementMoveEnd exists:', typeof onElementMoveEnd === 'function')
      console.log('onDraggingChange exists:', typeof onDraggingChange === 'function')
    })

    onDraggingChange?.(true)

    setInternalSelected(zone.id)
    onZoneSelect?.(zone)

    const target = e.currentTarget // aquí es el <rect> (MUY IMPORTANTE)
    const { mx, my } = clientToMeters(e.clientX, e.clientY)

    dragRef.current = {
      targetEl: target.parentNode, // movemos el <g> entero
      elementId: zone.originalId || zone.id,
      startMouseX: mx,
      startMouseY: my,
      startX: zone.x,
      startY: zone.y,
      w: zone.width,
      h: zone.height,
      lastX: zone.x,
      lastY: zone.y
    }

    try { target.style.cursor = 'grabbing' } catch {}

    const onMove = (ev) => {
      if (!dragRef.current) return
      ev.preventDefault?.()

      const d = dragRef.current
      const p = clientToMeters(ev.clientX, ev.clientY)

      let newX = d.startX + (p.mx - d.startMouseX)
      let newY = d.startY + (p.my - d.startMouseY)

      newX = snap(newX, 0.5)
      newY = snap(newY, 0.5)
      newX = clamp(newX, 0, dimensions.length - d.w)
      newY = clamp(newY, 0, dimensions.width - d.h)

      d.lastX = newX
      d.lastY = newY

      const dxSvg = (newX - d.startX) * scale
      const dySvg = (newY - d.startY) * scale
      d.targetEl.setAttribute('transform', `translate(${dxSvg}, ${dySvg})`)

      if (DBG && Math.random() < 0.05) log('[DRAG][MOVE]', { newX, newY, dxSvg, dySvg })
    }

    const onUp = (ev) => {
      if (!dragRef.current) return
      ev.preventDefault?.()

      const d = dragRef.current
      dragRef.current = null

      try { d.targetEl.removeAttribute('transform') } catch {}
      try { target.style.cursor = 'grab' } catch {}

      onDraggingChange?.(false)

      group('[DRAG][UP]', () => {
        console.log('final:', { id: d.elementId, x: d.lastX, y: d.lastY })
      })

      if (typeof onElementMoveEnd !== 'function') {
        console.warn('[2DView] onElementMoveEnd is not a function -> cannot commit move')
      } else {
        onElementMoveEnd(d.elementId, d.lastX, d.lastY)
      }

      endDragCleanup(onMove, onUp)
    }

    // Pointer listeners
    window.addEventListener('pointermove', onMove, { passive: false })
    window.addEventListener('pointerup', onUp, { passive: false })
    window.addEventListener('pointercancel', onUp, { passive: false })
    // Mouse fallback (por si React/pointer rara vez falla)
    window.addEventListener('mousemove', onMove, { passive: false })
    window.addEventListener('mouseup', onUp, { passive: false })
  }, [
    clientToMeters,
    dimensions.length,
    dimensions.width,
    scale,
    offset,
    viewBox,
    onElementMoveEnd,
    onZoneSelect,
    onDraggingChange,
    endDragCleanup
  ])

  return (
    <Box
      ref={containerRef}
      sx={{
        width: '100%',
        height: '100%',
        bgcolor: '#fafafa',
        position: 'relative',
        overflow: 'hidden'
      }}
    >
      <svg
        ref={svgRef}
        width="100%"
        height="100%"
        viewBox={`0 0 ${viewBox.width} ${viewBox.height}`}
        style={{
          fontFamily: "'JetBrains Mono', 'Fira Code', 'SF Mono', monospace",
          userSelect: 'none',
          touchAction: 'none'
        }}
      >
        <defs>
          <marker id="arrow-start" markerWidth="8" markerHeight="8" refX="0" refY="4" orient="auto">
            <path d="M8,0 L0,4 L8,8" fill="none" stroke="#1e40af" strokeWidth="1" />
          </marker>
          <marker id="arrow-end" markerWidth="8" markerHeight="8" refX="8" refY="4" orient="auto">
            <path d="M0,0 L8,4 L0,8" fill="none" stroke="#1e40af" strokeWidth="1" />
          </marker>
          <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
            <feDropShadow dx="2" dy="2" stdDeviation="3" floodOpacity="0.15" />
          </filter>
        </defs>

        <rect x={0} y={0} width={viewBox.width} height={viewBox.height} fill="#fafafa" />

        {showGrid && <Grid2D dimensions={dimensions} scale={scale} offset={offset} gridSize={5} />}

        <rect
          x={offset.x}
          y={offset.y}
          width={dimensions.length * scale}
          height={dimensions.width * scale}
          fill="#ffffff"
          stroke="#374151"
          strokeWidth={3}
          filter="url(#shadow)"
        />

        <g className="zones">
          {zones.filter(z => ['aisle', 'main_aisle', 'cross_aisle', 'circulation'].includes(z.type)).map(zone => (
            <Zone2D
              key={zone.id}
              zone={zone}
              scale={scale}
              offset={offset}
              isSelected={effectiveSelected === zone.id}
              isHovered={effectiveHover === zone.id}
              onMouseEnter={handleZoneMouseEnter}
              onMouseLeave={handleZoneMouseLeave}
              onClick={handleZoneClick}
              onPointerDownZone={onPointerDownZone}
            />
          ))}

          {zones.filter(z => z.type === 'dock_maneuver').map(zone => (
            <Zone2D
              key={zone.id}
              zone={zone}
              scale={scale}
              offset={offset}
              isSelected={effectiveSelected === zone.id || effectiveSelected === zone.originalId}
              isHovered={effectiveHover === zone.id || effectiveHover === zone.originalId}
              onMouseEnter={handleZoneMouseEnter}
              onMouseLeave={handleZoneMouseLeave}
              onClick={handleZoneClick}
              onPointerDownZone={onPointerDownZone}
            />
          ))}

          {zones.filter(z => ['operational_zone', 'zone', 'receiving', 'shipping', 'picking'].includes(z.type)).map(zone => (
            <Zone2D
              key={zone.id}
              zone={zone}
              scale={scale}
              offset={offset}
              isSelected={effectiveSelected === zone.id}
              isHovered={effectiveHover === zone.id}
              onMouseEnter={handleZoneMouseEnter}
              onMouseLeave={handleZoneMouseLeave}
              onClick={handleZoneClick}
              onPointerDownZone={onPointerDownZone}
            />
          ))}

          {zones.filter(z => ['office', 'service_room', 'technical_room'].includes(z.type)).map(zone => (
            <Zone2D
              key={zone.id}
              zone={zone}
              scale={scale}
              offset={offset}
              isSelected={effectiveSelected === zone.id}
              isHovered={effectiveHover === zone.id}
              onMouseEnter={handleZoneMouseEnter}
              onMouseLeave={handleZoneMouseLeave}
              onClick={handleZoneClick}
              onPointerDownZone={onPointerDownZone}
            />
          ))}

          {zones.filter(z => z.type === 'shelf').map(zone => (
            <Zone2D
              key={zone.id}
              zone={zone}
              scale={scale}
              offset={offset}
              isSelected={effectiveSelected === zone.id}
              isHovered={effectiveHover === zone.id}
              onMouseEnter={handleZoneMouseEnter}
              onMouseLeave={handleZoneMouseLeave}
              onClick={handleZoneClick}
              onPointerDownZone={onPointerDownZone}
            />
          ))}

          {zones.filter(z => z.type === 'dock').map(zone => (
            <Zone2D
              key={zone.id}
              zone={zone}
              scale={scale}
              offset={offset}
              isSelected={effectiveSelected === zone.id}
              isHovered={effectiveHover === zone.id}
              onMouseEnter={handleZoneMouseEnter}
              onMouseLeave={handleZoneMouseLeave}
              onClick={handleZoneClick}
              onPointerDownZone={onPointerDownZone}
            />
          ))}
        </g>

        {showDimensions && <DimensionLines dimensions={dimensions} scale={scale} offset={offset} />}

        <text
          x={viewBox.width / 2}
          y={25}
          textAnchor="middle"
          fontSize={14}
          fontWeight={700}
          fill="#1f2937"
        >
          PLANO DE PLANTA - {dimensions.length}m × {dimensions.width}m ({(dimensions.length * dimensions.width).toLocaleString()}m²)
        </text>
      </svg>

      <Box
        sx={{
          position: 'absolute',
          bottom: 16,
          left: 16,
          bgcolor: 'rgba(255,255,255,0.95)',
          borderRadius: 1,
          px: 2,
          py: 1,
          boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
          fontFamily: 'monospace',
          fontSize: 11
        }}
      >
        <Typography variant="caption" sx={{ fontWeight: 600, color: '#374151' }}>
          Zonas: {zones.length} | Ocupado: {zones.occupiedArea?.toFixed(0) || 0}m² | Libre: {zones.freeArea?.toFixed(0) || 0}m²
        </Typography>
      </Box>
    </Box>
  )
}

export { processElementsToZones, ZONE_COLORS }
