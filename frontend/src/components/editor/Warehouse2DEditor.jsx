/**
 * UNITNAVE Designer - Editor 2D CAD Completo
 *
 * Integra:
 * - Vista 2D en planta (Warehouse2DView) con cotas
 * - Leyenda lateral interactiva (ZonesLegend)
 * - Toolbar con controles
 * - SincronizaciÃ³n hover/selecciÃ³n
 * - CÃ¡lculo exacto de zonas via backend (Shapely) /analyze
 * - âœ… Drag real (en Warehouse2DView) + re-optimizaciÃ³n (OR-Tools backend) /full
 *
 * @version 2.2 - Completo: COTAS + DRAG + ORTOOLS
 */

import React, { useState, useCallback, useMemo, useEffect, useRef } from 'react'
import {
  Box,
  Paper,
  IconButton,
  Tooltip,
  Typography,
  Divider,
  Slider,
  Chip,
  CircularProgress
} from '@mui/material'
import {
  ZoomIn as ZoomInIcon,
  ZoomOut as ZoomOutIcon,
  CenterFocusStrong as CenterIcon,
  GridOn as GridIcon,
  GridOff as GridOffIcon,
  Straighten as DimensionsIcon,
  Download as ExportIcon,
  Print as PrintIcon,
  ViewInAr as View3DIcon,
  Info as InfoIcon
} from '@mui/icons-material'

import Warehouse2DView, { processElementsToZones, ZONE_COLORS } from './Warehouse2DView'
import ZonesLegend from './ZonesLegend'

// ===================== DEBUG =====================
const DBG = true
const log = (...a) => DBG && console.log('[2DEditor]', ...a)
const group = (t, fn) => {
  if (!DBG) return
  console.groupCollapsed(t)
  try { fn?.() } finally { console.groupEnd() }
}
// ================================================

// ============================================================
// API CONFIGURATION
// ============================================================
const API_URL = import.meta.env.VITE_API_URL || 'https://unitnave-designer-production.up.railway.app'

// ============================================================
// HOOK PARA OBTENER ZONAS DEL BACKEND (GeometrÃ­a Exacta)
// - pause=true => no llama (Ãºtil mientras arrastras)
// ============================================================
function useBackendZones(dimensions, elements, pause = false) {
  const [backendZones, setBackendZones] = useState(null)
  const [metrics, setMetrics] = useState(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)

  useEffect(() => {
    if (pause) {
      log('[analyze] PAUSED (dragging)')
      return
    }

    if (!elements || elements.length === 0) {
      setBackendZones(null)
      setMetrics(null)
      return
    }

    const fetchZones = async () => {
      setLoading(true)
      setError(null)

      try {
        log('[analyze] POST', `${API_URL}/api/layout/analyze`, { elements: elements.length, dimensions })
        const response = await fetch(`${API_URL}/api/layout/analyze`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            dimensions: { length: dimensions.length, width: dimensions.width },
            elements
          })
        })

        if (!response.ok) throw new Error(`HTTP ${response.status}`)

        const data = await response.json()
        log('[analyze] OK zones:', data.zones?.length)

        const convertedZones = (data.zones || []).map(zone => ({
          ...zone,
          originalId: zone.id,
          rotation: 0,
          isAutoGenerated: true
        }))

        setBackendZones(convertedZones)
        setMetrics(data.metrics || null)
      } catch (err) {
        log('[analyze] FAIL', err?.message)
        setError(err?.message || 'Analyze error')
        setBackendZones(null)
      } finally {
        setLoading(false)
      }
    }

    const timeoutId = setTimeout(fetchZones, 300)
    return () => clearTimeout(timeoutId)
  }, [dimensions.length, dimensions.width, elements, pause])

  return { backendZones, metrics, loading, error }
}

// ============================================================
// HOOK FULL (OPTIMIZA AL MOVER) - OR-TOOLS
// ============================================================
function useLayoutFullAPI() {
  const [optimizing, setOptimizing] = useState(false)
  const [optError, setOptError] = useState(null)

  const full = useCallback(async (dimensions, elements, movedId = null, movedPos = null) => {
    setOptimizing(true)
    setOptError(null)

    try {
      log('[full] POST', `${API_URL}/api/layout/full`, { movedId, movedPos, elements: elements.length })
      const response = await fetch(`${API_URL}/api/layout/full`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          dimensions: { length: dimensions.length, width: dimensions.width },
          elements,
          moved_element_id: movedId,
          moved_position: movedPos,
          optimize: !!movedId
        })
      })

      if (!response.ok) throw new Error(`HTTP ${response.status}`)
      const json = await response.json()
      log('[full] OK elements:', json?.elements?.length)
      return json
    } catch (err) {
      log('[full] FAIL', err?.message)
      setOptError(err?.message || 'Full error')
      return null
    } finally {
      setOptimizing(false)
    }
  }, [])

  return { optimizing, optError, full }
}

// ============================================================
// TOOLBAR 2D
// ============================================================
function Toolbar2D({
  showGrid,
  onToggleGrid,
  showDimensions,
  onToggleDimensions,
  onCenter,
  onExport,
  onPrint,
  onSwitch3D,
  zoom,
  onZoomChange,
  loadingAny
}) {
  return (
    <Paper
      elevation={2}
      sx={{
        position: 'absolute',
        top: 12,
        left: '50%',
        transform: 'translateX(-50%)',
        display: 'flex',
        alignItems: 'center',
        gap: 0.5,
        px: 1.5,
        py: 0.75,
        borderRadius: 2,
        bgcolor: 'rgba(255, 255, 255, 0.95)',
        backdropFilter: 'blur(8px)',
        zIndex: 100
      }}
    >
      <Tooltip title={showGrid ? 'Ocultar Grid' : 'Mostrar Grid'}>
        <IconButton size="small" onClick={onToggleGrid} color={showGrid ? 'primary' : 'default'}>
          {showGrid ? <GridIcon fontSize="small" /> : <GridOffIcon fontSize="small" />}
        </IconButton>
      </Tooltip>

      <Tooltip title={showDimensions ? 'Ocultar Cotas' : 'Mostrar Cotas'}>
        <IconButton size="small" onClick={onToggleDimensions} color={showDimensions ? 'primary' : 'default'}>
          <DimensionsIcon fontSize="small" />
        </IconButton>
      </Tooltip>

      <Divider orientation="vertical" flexItem sx={{ mx: 0.5 }} />

      <Tooltip title="Alejar">
        <IconButton size="small" onClick={() => onZoomChange(Math.max(50, zoom - 10))} disabled={zoom <= 50}>
          <ZoomOutIcon fontSize="small" />
        </IconButton>
      </Tooltip>

      <Box sx={{ width: 80, mx: 1 }}>
        <Slider
          value={zoom}
          onChange={(_, v) => onZoomChange(v)}
          min={50}
          max={200}
          step={10}
          size="small"
          valueLabelDisplay="auto"
          valueLabelFormat={(v) => `${v}%`}
        />
      </Box>

      <Tooltip title="Acercar">
        <IconButton size="small" onClick={() => onZoomChange(Math.min(200, zoom + 10))} disabled={zoom >= 200}>
          <ZoomInIcon fontSize="small" />
        </IconButton>
      </Tooltip>

      <Chip
        label={`${zoom}%`}
        size="small"
        variant="outlined"
        sx={{ height: 24, fontSize: 10, fontFamily: 'monospace' }}
      />

      <Divider orientation="vertical" flexItem sx={{ mx: 0.5 }} />

      <Tooltip title="Centrar Vista">
        <IconButton size="small" onClick={onCenter}>
          <CenterIcon fontSize="small" />
        </IconButton>
      </Tooltip>

      <Tooltip title="Exportar PNG">
        <IconButton size="small" onClick={onExport} disabled={loadingAny}>
          <ExportIcon fontSize="small" />
        </IconButton>
      </Tooltip>

      <Tooltip title="Imprimir">
        <IconButton size="small" onClick={onPrint}>
          <PrintIcon fontSize="small" />
        </IconButton>
      </Tooltip>

      <Divider orientation="vertical" flexItem sx={{ mx: 0.5 }} />

      <Tooltip title="Cambiar a Vista 3D">
        <IconButton
          size="small"
          onClick={onSwitch3D}
          sx={{
            bgcolor: 'primary.main',
            color: 'white',
            '&:hover': { bgcolor: 'primary.dark' }
          }}
        >
          <View3DIcon fontSize="small" />
        </IconButton>
      </Tooltip>

      {loadingAny && <CircularProgress size={18} sx={{ ml: 1 }} />}
    </Paper>
  )
}

// ============================================================
// PANEL INFO ZONA SELECCIONADA
// ============================================================
function SelectedZoneInfo({ zone, dimensions }) {
  if (!zone) return null

  const colors = ZONE_COLORS?.[zone.type] || ZONE_COLORS?.free_zone || { fill: '#94a3b8', stroke: '#475569' }
  const totalArea = dimensions.length * dimensions.width
  const percentage = totalArea > 0 ? ((zone.area / totalArea) * 100).toFixed(2) : '0.00'

  return (
    <Paper
      elevation={3}
      sx={{
        position: 'absolute',
        bottom: 16,
        left: '50%',
        transform: 'translateX(-50%)',
        px: 3,
        py: 1.5,
        borderRadius: 2,
        bgcolor: 'rgba(255, 255, 255, 0.98)',
        backdropFilter: 'blur(8px)',
        zIndex: 100,
        display: 'flex',
        alignItems: 'center',
        gap: 3,
        minWidth: 420
      }}
    >
      <Box
        sx={{
          width: 40,
          height: 40,
          borderRadius: 1,
          bgcolor: colors.fill,
          border: `3px solid ${colors.stroke}`,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}
      >
        <Typography sx={{ color: 'white', fontWeight: 800, fontSize: 14 }}>
          {zone.type?.charAt(0)?.toUpperCase?.() || '?'}
        </Typography>
      </Box>

      <Box sx={{ flex: 1 }}>
        <Typography variant="subtitle2" sx={{ fontWeight: 800, color: '#1f2937' }}>
          {zone.label || zone.id}
        </Typography>
        <Typography variant="caption" sx={{ color: '#64748b' }}>
          {colors.label || zone.type}
        </Typography>
      </Box>

      <Box sx={{ textAlign: 'center' }}>
        <Typography variant="h6" sx={{ fontFamily: 'monospace', fontWeight: 800, color: '#1e40af', lineHeight: 1 }}>
          {Number(zone.width || 0).toFixed(1)}m Ã— {Number(zone.height || 0).toFixed(1)}m
        </Typography>
        <Typography variant="caption" sx={{ color: '#64748b' }}>Dimensiones</Typography>
      </Box>

      <Box sx={{ textAlign: 'center' }}>
        <Typography variant="h6" sx={{ fontFamily: 'monospace', fontWeight: 800, color: '#059669', lineHeight: 1 }}>
          {Number(zone.area || 0).toFixed(1)}mÂ²
        </Typography>
        <Typography variant="caption" sx={{ color: '#64748b' }}>Superficie</Typography>
      </Box>

      <Box sx={{ textAlign: 'center' }}>
        <Typography variant="h6" sx={{ fontFamily: 'monospace', fontWeight: 800, color: '#7c3aed', lineHeight: 1 }}>
          {percentage}%
        </Typography>
        <Typography variant="caption" sx={{ color: '#64748b' }}>del Total</Typography>
      </Box>

      <Box sx={{ textAlign: 'center' }}>
        <Typography variant="body2" sx={{ fontFamily: 'monospace', fontWeight: 700, color: '#374151', lineHeight: 1 }}>
          ({Number(zone.x || 0).toFixed(1)}, {Number(zone.y || 0).toFixed(1)})
        </Typography>
        <Typography variant="caption" sx={{ color: '#64748b' }}>PosiciÃ³n</Typography>
      </Box>
    </Paper>
  )
}

// ============================================================
// COMPONENTE PRINCIPAL
// ============================================================
export default function Warehouse2DEditor({
  dimensions = { length: 80, width: 40, height: 10 },
  elements = [],
  onSwitch3D,
  onElementsChange
}) {
  useEffect(() => {
    console.log('[LOAD][Warehouse2DEditor]', import.meta?.url || '(no import.meta.url)')
  }, [])

  // âœ… ÃšNICA fuente de verdad en el editor
  const [localElements, setLocalElements] = useState(elements || [])
  const elementsRef = useRef(localElements)

  useEffect(() => {
    log('[props] elements changed -> localElements', (elements || []).length)
    setLocalElements(elements || [])
  }, [elements])

  useEffect(() => {
    elementsRef.current = localElements
    log('[state] localElements:', localElements.length)
  }, [localElements])

  // Estado UI
  const [hoveredZoneId, setHoveredZoneId] = useState(null)
  const [selectedZone, setSelectedZone] = useState(null)
  const [showGrid, setShowGrid] = useState(true)
  const [showDimensions, setShowDimensions] = useState(true)
  const [zoom, setZoom] = useState(100)
  const [showLegend, setShowLegend] = useState(true)
  const [isDraggingElement, setIsDraggingElement] = useState(false)

  // Backend: full (OR-Tools)
  const { optimizing, optError, full } = useLayoutFullAPI()

  // Backend: analyze (Shapely) -> pausamos mientras arrastras
  const { backendZones, metrics, loading: loadingAnalyze, error } =
    useBackendZones(dimensions, localElements, isDraggingElement)

  // Local zones (fallback / para elementos reales)
  const localZones = useMemo(() => processElementsToZones(localElements, dimensions), [localElements, dimensions])

  // Zonas a mostrar (combina elementos reales + backend auto-zones)
  const zones = useMemo(() => {
    if (backendZones && backendZones.length > 0) {
      const elementZones = localZones.filter(z => !z.isAutoGenerated)
      return [...elementZones, ...backendZones]
    }
    return localZones
  }, [backendZones, localZones])

  // MÃ©tricas
  const displayMetrics = useMemo(() => {
    if (metrics) return metrics
    const totalArea = dimensions.length * dimensions.width
    const occupiedArea = localZones.occupiedArea || 0
    const freeArea = localZones.freeArea ?? (totalArea - occupiedArea)
    const efficiency = totalArea > 0 ? ((occupiedArea / totalArea) * 100).toFixed(1) : '0.0'
    return { totalArea, occupiedArea, freeArea, efficiency }
  }, [metrics, localZones, dimensions])

  // Zona seleccionada completa
  const selectedZoneData = useMemo(() => {
    if (!selectedZone) return null
    return zones.find(z => z.id === selectedZone.id) || selectedZone
  }, [selectedZone, zones])

  // Handlers hover/selecciÃ³n
  const handleZoneHover = useCallback((id) => setHoveredZoneId(id), [])
  const handleZoneSelect = useCallback((zone) => {
    group('[select] zone', () => {
      console.log('zone:', zone)
      console.log('type:', zone?.type, 'auto:', zone?.isAutoGenerated, 'hasElement:', !!zone?.element)
    })
    setSelectedZone(prev => (prev?.id === zone.id ? null : zone))
  }, [])

  // Center
  const handleCenter = useCallback(() => setZoom(100), [])

  // Export
  const handleExport = useCallback(() => {
    const svg = document.querySelector('.warehouse-2d-view svg')
    if (!svg) return

    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')
    if (!ctx) return

    const data = new XMLSerializer().serializeToString(svg)
    const img = new Image()

    img.onload = () => {
      canvas.width = img.width * 2
      canvas.height = img.height * 2
      ctx.fillStyle = '#ffffff'
      ctx.fillRect(0, 0, canvas.width, canvas.height)
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height)

      const link = document.createElement('a')
      link.download = `plano-nave-${dimensions.length}x${dimensions.width}.png`
      link.href = canvas.toDataURL('image/png')
      link.click()
    }

    img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(data)))
  }, [dimensions])

  // Print
  const handlePrint = useCallback(() => window.print(), [])

  // ============================================================
  // âœ… PUNTO CLAVE: AL SOLTAR UN ELEMENTO -> ORTOOLS
  // ============================================================
  const handleElementMoveEnd = useCallback(async (elementId, newX, newY) => {
    group('[MOVE_END] from view', () => {
      console.log('elementId:', elementId)
      console.log('newX,newY:', newX, newY)
    })

    const current = elementsRef.current || []
    const moved = current.find(e => e.id === elementId)

    if (!moved) {
      console.warn('[2DEditor] moved element NOT FOUND in current elementsRef', elementId, current.map(e => e.id))
      return
    }

    // 1) Optimistic local update (feedback inmediato)
    const optimistic = current.map(e =>
      e.id === elementId ? { ...e, position: { ...(e.position || {}), x: newX, y: newY } } : e
    )
    setLocalElements(optimistic)

    // 2) Backend solver
    const result = await full(dimensions, optimistic, elementId, { x: newX, y: newY })
    if (!result || !result.elements) {
      console.warn('[2DEditor] full() returned null/invalid -> keeping optimistic')
      return
    }

    // 3) Aplicar soluciÃ³n final
    setLocalElements(result.elements)
    onElementsChange?.(result.elements)
  }, [dimensions, full, onElementsChange])

  const loadingAny = loadingAnalyze || optimizing

  return (
    <Box sx={{ width: '100%', height: '100%', display: 'flex', position: 'relative', bgcolor: '#f8fafc' }}>
      <Box className="warehouse-2d-view" sx={{ flex: 1, position: 'relative', overflow: 'hidden' }}>
        <Toolbar2D
          showGrid={showGrid}
          onToggleGrid={() => setShowGrid(p => !p)}
          showDimensions={showDimensions}
          onToggleDimensions={() => setShowDimensions(p => !p)}
          onCenter={handleCenter}
          onExport={handleExport}
          onPrint={handlePrint}
          onSwitch3D={onSwitch3D}
          zoom={zoom}
          onZoomChange={setZoom}
          loadingAny={loadingAny}
        />

        {loadingAny && (
          <Box sx={{
            position: 'absolute',
            top: 70,
            left: '50%',
            transform: 'translateX(-50%)',
            zIndex: 200,
            display: 'flex',
            alignItems: 'center',
            gap: 1,
            bgcolor: 'rgba(255,255,255,0.92)',
            px: 2,
            py: 0.75,
            borderRadius: 1
          }}>
            <CircularProgress size={16} />
            <Typography variant="caption">
              {optimizing ? 'Optimizando (OR-Tools)...' : 'Calculando geometrÃ­a exacta...'}
            </Typography>
          </Box>
        )}

        {/* Vista 2D con zoom visual */}
        <Box
          sx={{
            width: '100%',
            height: '100%',
            transform: `scale(${zoom / 100})`,
            transformOrigin: 'center center',
            transition: 'transform 0.15s ease'
          }}
        >
          <Warehouse2DView
            dimensions={dimensions}
            elements={localElements}
            selectedZoneId={selectedZone?.id}
            hoveredZoneId={hoveredZoneId}
            onZoneSelect={handleZoneSelect}
            onZoneHover={handleZoneHover}
            externalZones={backendZones}
            showGrid={showGrid}
            showDimensions={showDimensions}
            zoom={zoom}

            // âœ… DRAG REAL (nombre correcto)
            onElementMoveEnd={handleElementMoveEnd}

            // âœ… ahora sÃ­: pausar analyze mientras arrastras
            onDraggingChange={setIsDraggingElement}
          />
        </Box>

        {backendZones && (
          <Chip label="ðŸ“ GeometrÃ­a Exacta" size="small" color="success"
            sx={{ position: 'absolute', top: 60, left: 12, zIndex: 100, fontSize: '11px' }} />
        )}

        {error && !backendZones && (
          <Chip label="âš ï¸ Modo Local" size="small" color="warning"
            sx={{ position: 'absolute', top: 60, left: 12, zIndex: 100, fontSize: '11px' }} />
        )}

        {optError && (
          <Chip label={`âŒ Optimizer: ${optError}`} size="small" color="error"
            sx={{ position: 'absolute', top: 84, left: 12, zIndex: 100, fontSize: '11px' }} />
        )}

        <Paper
          elevation={2}
          sx={{
            position: 'absolute',
            bottom: 16,
            left: 16,
            px: 2,
            py: 1,
            borderRadius: 1,
            bgcolor: 'rgba(255,255,255,0.92)',
            fontFamily: 'monospace',
            zIndex: 120
          }}
        >
          <Typography variant="caption" sx={{ fontWeight: 700, color: '#374151' }}>
            Total: {Number(displayMetrics.totalArea || 0).toFixed(0)}mÂ² | Ocupado: {Number(displayMetrics.occupiedArea || 0).toFixed(0)}mÂ² | Libre: {Number(displayMetrics.freeArea || 0).toFixed(0)}mÂ² | Eficiencia: {displayMetrics.efficiency || '0.0'}%
          </Typography>
        </Paper>

        <SelectedZoneInfo zone={selectedZoneData} dimensions={dimensions} />

        {!showLegend && (
          <Tooltip title="Mostrar Leyenda">
            <IconButton
              onClick={() => setShowLegend(true)}
              sx={{
                position: 'absolute',
                top: 12,
                right: 12,
                bgcolor: 'white',
                boxShadow: 2,
                '&:hover': { bgcolor: '#f1f5f9' }
              }}
            >
              <InfoIcon />
            </IconButton>
          </Tooltip>
        )}
      </Box>

      {showLegend && (
        <Box sx={{ position: 'relative' }}>
          <IconButton
            size="small"
            onClick={() => setShowLegend(false)}
            sx={{
              position: 'absolute',
              top: 8,
              right: 8,
              zIndex: 10,
              color: 'white',
              bgcolor: 'rgba(0,0,0,0.3)',
              '&:hover': { bgcolor: 'rgba(0,0,0,0.5)' }
            }}
          >
            Ã—
          </IconButton>

          <ZonesLegend
            dimensions={dimensions}
            elements={localElements}
            hoveredZoneId={hoveredZoneId}
            selectedZoneId={selectedZone?.id}
            onZoneHover={handleZoneHover}
            onZoneSelect={handleZoneSelect}
            width={280}
            externalZones={backendZones}
          />
        </Box>
      )}
    </Box>
  )
}
