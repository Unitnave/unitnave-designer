/**
 * UNITNAVE Designer - Editor 2D CAD Completo
 *
 * Integra:
 * - Vista 2D en planta (Warehouse2DView) con cotas
 * - Leyenda lateral interactiva (ZonesLegend)
 * - Toolbar con controles
 * - Sincronizaci√≥n hover/selecci√≥n
 * - C√°lculo exacto de zonas via backend (Shapely)
 * - ‚úÖ Drag & drop de elementos + re-optimizaci√≥n (OR-Tools backend)
 *
 * @version 2.2 - Unificado: COTAS + DRAG REAL + ORTOOLS
 */

import React, { useState, useCallback, useMemo, useEffect, useRef } from 'react'
import {
  Box,
  Paper,
  IconButton,
  Tooltip,
  Typography,
  Divider,
  Slider,
  Chip,
  CircularProgress
} from '@mui/material'
import {
  ZoomIn as ZoomInIcon,
  ZoomOut as ZoomOutIcon,
  CenterFocusStrong as CenterIcon,
  GridOn as GridIcon,
  GridOff as GridOffIcon,
  Straighten as DimensionsIcon,
  Download as ExportIcon,
  Print as PrintIcon,
  ViewInAr as View3DIcon,
  Info as InfoIcon
} from '@mui/icons-material'

import Warehouse2DView, { processElementsToZones, ZONE_COLORS } from './Warehouse2DView'
import ZonesLegend from './ZonesLegend'

// ============================================================
// API CONFIGURATION
// ============================================================
const API_URL = import.meta.env.VITE_API_URL || 'https://unitnave-designer-production.up.railway.app'

// ============================================================
// HOOK PARA OBTENER ZONAS DEL BACKEND (Geometr√≠a Exacta)
// üëá IMPORTANT√çSIMO: si estamos arrastrando, NO llamamos al backend
// ============================================================
function useBackendZones(dimensions, elements, isDraggingElement) {
  const [backendZones, setBackendZones] = useState(null)
  const [metrics, setMetrics] = useState(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)

  useEffect(() => {
    if (isDraggingElement) return

    if (!elements || elements.length === 0) {
      setBackendZones(null)
      setMetrics(null)
      return
    }

    const fetchZones = async () => {
      setLoading(true)
      setError(null)

      try {
        const response = await fetch(`${API_URL}/api/layout/analyze`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            dimensions: { length: dimensions.length, width: dimensions.width },
            elements
          })
        })

        if (!response.ok) throw new Error(`HTTP ${response.status}`)

        const data = await response.json()

        const convertedZones = (data.zones || []).map(zone => ({
          ...zone,
          originalId: zone.id,
          rotation: 0,
          isAutoGenerated: true
        }))

        setBackendZones(convertedZones)
        setMetrics(data.metrics || null)
      } catch (err) {
        setError(err?.message || 'Analyze error')
        setBackendZones(null)
        setMetrics(null)
      } finally {
        setLoading(false)
      }
    }

    const t = setTimeout(fetchZones, 250)
    return () => clearTimeout(t)
  }, [dimensions.length, dimensions.width, elements, isDraggingElement])

  return { backendZones, metrics, loading, error }
}

// ============================================================
// HOOK FULL (OPTIMIZA AL MOVER) - OR-TOOLS
// ============================================================
function useLayoutFullAPI() {
  const [optimizing, setOptimizing] = useState(false)
  const [optError, setOptError] = useState(null)

  const full = useCallback(async (dimensions, elements, movedId = null, movedPos = null) => {
    setOptimizing(true)
    setOptError(null)

    try {
      const response = await fetch(`${API_URL}/api/layout/full`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          dimensions: { length: dimensions.length, width: dimensions.width },
          elements,
          moved_element_id: movedId,
          moved_position: movedPos,
          optimize: !!movedId
        })
      })

      if (!response.ok) throw new Error(`HTTP ${response.status}`)
      return await response.json()
    } catch (err) {
      setOptError(err?.message || 'Full error')
      return null
    } finally {
      setOptimizing(false)
    }
  }, [])

  return { optimizing, optError, full }
}

// ============================================================
// TOOLBAR 2D
// ============================================================
function Toolbar2D({
  showGrid,
  onToggleGrid,
  showDimensions,
  onToggleDimensions,
  onCenter,
  onExport,
  onPrint,
  onSwitch3D,
  zoom,
  onZoomChange,
  loadingAny
}) {
  return (
    <Paper
      elevation={2}
      sx={{
        position: 'absolute',
        top: 12,
        left: '50%',
        transform: 'translateX(-50%)',
        display: 'flex',
        alignItems: 'center',
        gap: 0.5,
        px: 1.5,
        py: 0.75,
        borderRadius: 2,
        bgcolor: 'rgba(255, 255, 255, 0.95)',
        backdropFilter: 'blur(8px)',
        zIndex: 100
      }}
    >
      <Tooltip title={showGrid ? 'Ocultar Grid' : 'Mostrar Grid'}>
        <IconButton size="small" onClick={onToggleGrid} color={showGrid ? 'primary' : 'default'}>
          {showGrid ? <GridIcon fontSize="small" /> : <GridOffIcon fontSize="small" />}
        </IconButton>
      </Tooltip>

      <Tooltip title={showDimensions ? 'Ocultar Cotas' : 'Mostrar Cotas'}>
        <IconButton size="small" onClick={onToggleDimensions} color={showDimensions ? 'primary' : 'default'}>
          <DimensionsIcon fontSize="small" />
        </IconButton>
      </Tooltip>

      <Divider orientation="vertical" flexItem sx={{ mx: 0.5 }} />

      <Tooltip title="Alejar">
        <IconButton size="small" onClick={() => onZoomChange(Math.max(50, zoom - 10))} disabled={zoom <= 50}>
          <ZoomOutIcon fontSize="small" />
        </IconButton>
      </Tooltip>

      <Box sx={{ width: 80, mx: 1 }}>
        <Slider
          value={zoom}
          onChange={(_, v) => onZoomChange(v)}
          min={50}
          max={200}
          step={10}
          size="small"
          valueLabelDisplay="auto"
          valueLabelFormat={(v) => `${v}%`}
        />
      </Box>

      <Tooltip title="Acercar">
        <IconButton size="small" onClick={() => onZoomChange(Math.min(200, zoom + 10))} disabled={zoom >= 200}>
          <ZoomInIcon fontSize="small" />
        </IconButton>
      </Tooltip>

      <Chip
        label={`${zoom}%`}
        size="small"
        variant="outlined"
        sx={{ height: 24, fontSize: 10, fontFamily: 'monospace' }}
      />

      <Divider orientation="vertical" flexItem sx={{ mx: 0.5 }} />

      <Tooltip title="Centrar Vista">
        <IconButton size="small" onClick={onCenter}>
          <CenterIcon fontSize="small" />
        </IconButton>
      </Tooltip>

      <Tooltip title="Exportar PNG">
        <IconButton size="small" onClick={onExport} disabled={loadingAny}>
          <ExportIcon fontSize="small" />
        </IconButton>
      </Tooltip>

      <Tooltip title="Imprimir">
        <IconButton size="small" onClick={onPrint}>
          <PrintIcon fontSize="small" />
        </IconButton>
      </Tooltip>

      <Divider orientation="vertical" flexItem sx={{ mx: 0.5 }} />

      <Tooltip title="Cambiar a Vista 3D">
        <IconButton
          size="small"
          onClick={onSwitch3D}
          sx={{ bgcolor: 'primary.main', color: 'white', '&:hover': { bgcolor: 'primary.dark' } }}
        >
          <View3DIcon fontSize="small" />
        </IconButton>
      </Tooltip>

      {loadingAny && <CircularProgress size={18} sx={{ ml: 1 }} />}
    </Paper>
  )
}

// ============================================================
// PANEL INFO ZONA SELECCIONADA
// ============================================================
function SelectedZoneInfo({ zone, dimensions }) {
  if (!zone) return null

  const colors = ZONE_COLORS[zone.type] || ZONE_COLORS.free_zone
  const totalArea = dimensions.length * dimensions.width
  const percentage = ((zone.area / totalArea) * 100).toFixed(2)

  return (
    <Paper
      elevation={3}
      sx={{
        position: 'absolute',
        bottom: 16,
        left: '50%',
        transform: 'translateX(-50%)',
        px: 3,
        py: 1.5,
        borderRadius: 2,
        bgcolor: 'rgba(255, 255, 255, 0.98)',
        backdropFilter: 'blur(8px)',
        zIndex: 100,
        display: 'flex',
        alignItems: 'center',
        gap: 3,
        minWidth: 400
      }}
    >
      <Box
        sx={{
          width: 40,
          height: 40,
          borderRadius: 1,
          bgcolor: colors.fill,
          border: `3px solid ${colors.stroke}`,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}
      >
        <Typography sx={{ color: 'white', fontWeight: 700, fontSize: 14 }}>
          {zone.type.charAt(0).toUpperCase()}
        </Typography>
      </Box>

      <Box sx={{ flex: 1 }}>
        <Typography variant="subtitle2" sx={{ fontWeight: 700, color: '#1f2937' }}>
          {zone.label}
        </Typography>
        <Typography variant="caption" sx={{ color: '#64748b' }}>
          {colors.label || zone.type}
        </Typography>
      </Box>

      <Box sx={{ textAlign: 'center' }}>
        <Typography variant="h6" sx={{ fontFamily: 'monospace', fontWeight: 700, color: '#1e40af', lineHeight: 1 }}>
          {zone.width.toFixed(1)}m √ó {zone.height.toFixed(1)}m
        </Typography>
        <Typography variant="caption" sx={{ color: '#64748b' }}>
          Dimensiones
        </Typography>
      </Box>

      <Box sx={{ textAlign: 'center' }}>
        <Typography variant="h6" sx={{ fontFamily: 'monospace', fontWeight: 700, color: '#059669', lineHeight: 1 }}>
          {zone.area.toFixed(1)}m¬≤
        </Typography>
        <Typography variant="caption" sx={{ color: '#64748b' }}>
          Superficie
        </Typography>
      </Box>

      <Box sx={{ textAlign: 'center' }}>
        <Typography variant="h6" sx={{ fontFamily: 'monospace', fontWeight: 700, color: '#7c3aed', lineHeight: 1 }}>
          {percentage}%
        </Typography>
        <Typography variant="caption" sx={{ color: '#64748b' }}>
          del Total
        </Typography>
      </Box>

      <Box sx={{ textAlign: 'center' }}>
        <Typography variant="body2" sx={{ fontFamily: 'monospace', fontWeight: 600, color: '#374151', lineHeight: 1 }}>
          ({zone.x.toFixed(1)}, {zone.y.toFixed(1)})
        </Typography>
        <Typography variant="caption" sx={{ color: '#64748b' }}>
          Posici√≥n
        </Typography>
      </Box>
    </Paper>
  )
}

// ============================================================
// HELPERS
// ============================================================
function applyElementPosition(list, elementId, x, y) {
  return (list || []).map(e => {
    if (e.id !== elementId) return e
    const pos = e.position || { x: 0, y: 0 }
    return {
      ...e,
      position: { ...pos, x, y, z: y } // mantenemos compatibilidad y/z
    }
  })
}

// ============================================================
// COMPONENTE PRINCIPAL
// ============================================================
export default function Warehouse2DEditor({
  dimensions = { length: 80, width: 40, height: 10 },
  elements = [],
  onSwitch3D,
  onElementsChange
}) {
  // Estado LOCAL de elementos (es el que se mueve)
  const [localElements, setLocalElements] = useState(elements || [])
  const elementsRef = useRef(localElements)

  // Estado de drag (para PAUSAR analyze durante drag)
  const [isDraggingElement, setIsDraggingElement] = useState(false)

  // Sync cuando llegan elements nuevos desde fuera
  useEffect(() => {
    setLocalElements(elements || [])
  }, [elements])

  // Ref siempre actualizado (evita closures viejas)
  useEffect(() => {
    elementsRef.current = localElements
  }, [localElements])

  // UI
  const [hoveredZoneId, setHoveredZoneId] = useState(null)
  const [selectedZone, setSelectedZone] = useState(null)
  const [showGrid, setShowGrid] = useState(true)
  const [showDimensions, setShowDimensions] = useState(true)
  const [zoom, setZoom] = useState(100)
  const [showLegend, setShowLegend] = useState(true)

  // Backend analyze (zonas exactas) ‚Äî usando localElements
  const { backendZones, metrics, loading: loadingAnalyze, error } =
    useBackendZones(dimensions, localElements, isDraggingElement)

  // Backend full (optimizaci√≥n al mover)
  const { optimizing, optError, full } = useLayoutFullAPI()

  // Zonas locales fallback
  const localZones = useMemo(() => {
    return processElementsToZones(localElements, dimensions)
  }, [localElements, dimensions])

  const zones = useMemo(() => {
    if (backendZones && backendZones.length > 0) {
      const elementZones = localZones.filter(z => !z.isAutoGenerated)
      return [...elementZones, ...backendZones]
    }
    return localZones
  }, [backendZones, localZones])

  const selectedZoneData = useMemo(() => {
    if (!selectedZone) return null
    return zones.find(z => z.id === selectedZone.id) || selectedZone
  }, [selectedZone, zones])

  // Handlers hover/select
  const handleZoneHover = useCallback((id) => setHoveredZoneId(id), [])
  const handleZoneSelect = useCallback((zone) => {
    setSelectedZone(prev => (prev?.id === zone.id ? null : zone))
  }, [])

  // Toolbar actions
  const handleCenter = useCallback(() => setZoom(100), [])

  const handleExport = useCallback(() => {
    const svg = document.querySelector('.warehouse-2d-view svg')
    if (!svg) return

    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')
    const data = new XMLSerializer().serializeToString(svg)
    const img = new Image()

    img.onload = () => {
      canvas.width = img.width * 2
      canvas.height = img.height * 2
      ctx.fillStyle = '#ffffff'
      ctx.fillRect(0, 0, canvas.width, canvas.height)
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height)
      const link = document.createElement('a')
      link.download = `plano-nave-${dimensions.length}x${dimensions.width}.png`
      link.href = canvas.toDataURL('image/png')
      link.click()
    }

    img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(data)))
  }, [dimensions.length, dimensions.width])

  const handlePrint = useCallback(() => window.print(), [])

  // ‚úÖ Drag: preview (mientras arrastras)
  const handleElementPreviewMove = useCallback((elementId, x, y) => {
    setLocalElements(prev => applyElementPosition(prev, elementId, x, y))
  }, [])

  // ‚úÖ Drag: start/end (para pausar analyze + optimizar al soltar)
  const handleElementDragStart = useCallback(() => {
    setIsDraggingElement(true)
  }, [])

  const handleElementDragEnd = useCallback(async (elementId, x, y) => {
    // 1) terminar drag y dejar posici√≥n final local
    setIsDraggingElement(false)

    const current = elementsRef.current || []
    const optimistic = applyElementPosition(current, elementId, x, y)
    setLocalElements(optimistic)

    // 2) optimizar con OR-Tools al soltar
    const result = await full(dimensions, optimistic, elementId, { x, y })
    if (result?.elements) {
      setLocalElements(result.elements)
      onElementsChange?.(result.elements)
    } else {
      // si falla, al menos mantenemos optimistic y notificamos
      onElementsChange?.(optimistic)
    }
  }, [dimensions, full, onElementsChange])

  const loadingAny = loadingAnalyze || optimizing

  return (
    <Box sx={{ width: '100%', height: '100%', display: 'flex', position: 'relative', bgcolor: '#f8fafc' }}>
      <Box className="warehouse-2d-view" sx={{ flex: 1, position: 'relative', overflow: 'hidden' }}>
        <Toolbar2D
          showGrid={showGrid}
          onToggleGrid={() => setShowGrid(p => !p)}
          showDimensions={showDimensions}
          onToggleDimensions={() => setShowDimensions(p => !p)}
          onCenter={handleCenter}
          onExport={handleExport}
          onPrint={handlePrint}
          onSwitch3D={onSwitch3D}
          zoom={zoom}
          onZoomChange={setZoom}
          loadingAny={loadingAny}
        />

        {loadingAny && (
          <Box sx={{
            position: 'absolute',
            top: 70,
            left: '50%',
            transform: 'translateX(-50%)',
            zIndex: 200,
            display: 'flex',
            alignItems: 'center',
            gap: 1,
            bgcolor: 'rgba(255,255,255,0.9)',
            px: 2,
            py: 0.5,
            borderRadius: 1
          }}>
            <CircularProgress size={16} />
            <Typography variant="caption">
              {optimizing ? 'Optimizando (OR-Tools)...' : 'Calculando geometr√≠a exacta...'}
            </Typography>
          </Box>
        )}

        <Box
          sx={{
            width: '100%',
            height: '100%',
            transform: `scale(${zoom / 100})`,
            transformOrigin: 'center center',
            transition: 'transform 0.2s ease'
          }}
        >
          <Warehouse2DView
            dimensions={dimensions}
            elements={localElements}
            selectedZoneId={selectedZone?.id}
            hoveredZoneId={hoveredZoneId}
            onZoneSelect={handleZoneSelect}
            onZoneHover={handleZoneHover}
            externalZones={backendZones}
            showGrid={showGrid}
            showDimensions={showDimensions}

            // ‚úÖ DRAG REAL
            onElementDragStart={handleElementDragStart}
            onElementPreviewMove={handleElementPreviewMove}
            onElementDragEnd={handleElementDragEnd}
          />
        </Box>

        {backendZones && (
          <Chip
            label="üìê Geometr√≠a Exacta"
            size="small"
            color="success"
            sx={{ position: 'absolute', top: 60, left: 12, zIndex: 100, fontSize: '11px' }}
          />
        )}

        {error && !backendZones && (
          <Chip
            label="‚ö†Ô∏è Modo Local"
            size="small"
            color="warning"
            sx={{ position: 'absolute', top: 60, left: 12, zIndex: 100, fontSize: '11px' }}
          />
        )}

        {optError && (
          <Chip
            label={`‚ùå Optimizer: ${optError}`}
            size="small"
            color="error"
            sx={{ position: 'absolute', top: 84, left: 12, zIndex: 100, fontSize: '11px' }}
          />
        )}

        <SelectedZoneInfo zone={selectedZoneData} dimensions={dimensions} />

        {!showLegend && (
          <Tooltip title="Mostrar Leyenda">
            <IconButton
              onClick={() => setShowLegend(true)}
              sx={{ position: 'absolute', top: 12, right: 12, bgcolor: 'white', boxShadow: 2, '&:hover': { bgcolor: '#f1f5f9' } }}
            >
              <InfoIcon />
            </IconButton>
          </Tooltip>
        )}
      </Box>

      {showLegend && (
        <Box sx={{ position: 'relative' }}>
          <IconButton
            size="small"
            onClick={() => setShowLegend(false)}
            sx={{
              position: 'absolute',
              top: 8,
              right: 8,
              zIndex: 10,
              color: 'white',
              bgcolor: 'rgba(0,0,0,0.3)',
              '&:hover': { bgcolor: 'rgba(0,0,0,0.5)' }
            }}
          >
            √ó
          </IconButton>

          <ZonesLegend
            dimensions={dimensions}
            elements={localElements}
            hoveredZoneId={hoveredZoneId}
            selectedZoneId={selectedZone?.id}
            onZoneHover={handleZoneHover}
            onZoneSelect={handleZoneSelect}
            width={280}
            externalZones={backendZones}
          />
        </Box>
      )}
    </Box>
  )
}
